# 《Java编程思想》Chapter 5 : 初始化与清理

**Initialization and Cleanup(初始化和清理)**  
编程方式中的设计安全的两个重要问题  
本章就将讨论这两个重要的问题  

- [1. 基础概念](#1-基础概念)
- [2. 用构造器确保初始化](#2-用构造器确保初始化)
    - [2.1. 构造器的命名来源](#21-构造器的命名来源)
    - [2.2. 构造器的定义](#22-构造器的定义)
- [3. 方法重载](#3-方法重载)
    - [3.1. 为什么我们需要方法重载？](#31-为什么我们需要方法重载)
    - [3.2. 方法重载的基础实例](#32-方法重载的基础实例)
    - [3.3. 区分重载方法](#33-区分重载方法)

## 1. 基础概念

- **Constructor(构造器)**  
    C++引入的概念，在对象被创建时自动调用的特殊方法  
    Java同样采用了构造器的概念  

- **垃圾回收器**  
    Java提供的内存资源回收机制，自动回收不再使用的内存

## 2. 用构造器确保初始化

假如没有构造器，我们会如何初始化对象呢？  
一个比较常规的想法就是为每个Class定义一个`initialize()`方法  
然后在每个对象创建时调用这个方法  
而在之后创建Object时，我们必须记得调用此方法  

但通过提供构造器，Class的设计者可以确保每个Object都得到正确的初始化  

### 2.1. 构造器的命名来源

问题：既然我们需要一个方法作为构造器，如何取名？  

考虑点：  

1. 防止与任何其他方法冲突  
2. 构造器由编译器负责，需要让编译器能够自动知道调用哪个方法

C++采用了与Class同名的方法作为构造器  
Java也继承了这种方式  

### 2.2. 构造器的定义

当我们定义了一个Class，如果我们没有定义构造器，编译器会自动为我们生成一个默认构造器  
但如果我们定义了一个构造器，编译器就不会再生成默认构造器  

因此如果我们定义了一个带参数的构造器  
那么我们之后创建Object时，就必须传入参数  

## 3. 方法重载

### 3.1. 为什么我们需要方法重载？

一般来说当我们定义了一个方法  
它所能接受的参数和处理的对象、逻辑都是固定的  
这就要求我们如果要处理不同的对象，就必须定义不同的方法  
按照一般的思路（例如C语言），我们就需要为这些对象分别分配不同的标识符  

但是对于我们实际生活中，例如“清洗”这个操作  
我们一般只会使用“清晰”+“对象”这两个信息来确定我们要进行的操作  
而不会使用“清洗类1的方法清洗”+“对象1”这种方式  

因此我们产生了一个想法就是：  
我们可以使用某一个通用的标识符，定义多个不同的方法，来处理不同的对象等  
这就是**方法重载**概念的主要来源  

### 3.2. 方法重载的基础实例

**Constructor就是一个重要例子**  

C++和Java中，构造器是强制重载方法名的另一个原因  
因为Constructor的名字已经与Class名绑定  
如果没有重载，我们就只能拥有一种构造方法了  
这显然是不满足我们的需求的  

### 3.3. 区分重载方法


<!-- ### UML

```plantuml
@startuml
class Person {
    - String name
    - int age
    + Person(String name, int age)
    + getName() : String
    + getAge() : int
}

Person : Person(String name, int age)
Person : getName() : String
Person : getAge() : int
@enduml
``` -->