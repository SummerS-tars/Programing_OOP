# 《Java编程思想》Chapter 5 : 初始化与清理

**Initialization and Cleanup(初始化和清理)**  
编程方式中的设计安全的两个重要问题  
本章就将讨论这两个重要的问题  

- [1. 基础概念](#1-基础概念)
- [2. 用构造器确保初始化](#2-用构造器确保初始化)
    - [2.1. 构造器的命名来源](#21-构造器的命名来源)
    - [2.2. 构造器的定义](#22-构造器的定义)
- [3. 方法重载](#3-方法重载)
    - [3.1. 为什么我们需要方法重载？](#31-为什么我们需要方法重载)
    - [3.2. 方法重载的基础实例](#32-方法重载的基础实例)
    - [3.3. 区分重载方法](#33-区分重载方法)
- [this关键字](#this关键字)
    - [this的一般用法](#this的一般用法)
    - [static含义](#static含义)
- [清理：终结处理和垃圾回收](#清理终结处理和垃圾回收)
    - [为什么？](#为什么)
    - [`finalize()`的用途何在？](#finalize的用途何在)
    - [终结条件](#终结条件)
    - [垃圾回收器如何工作](#垃圾回收器如何工作)
- [成员初始化](#成员初始化)
    - [指定初始化](#指定初始化)
- [构造器初始化](#构造器初始化)
    - [初始化顺序](#初始化顺序)
    - [静态数据的初始化](#静态数据的初始化)

## 1. 基础概念

- **Constructor(构造器)**  
    C++引入的概念，在对象被创建时自动调用的特殊方法  
    Java同样采用了构造器的概念  

- **垃圾回收器**  
    Java提供的内存资源回收机制，自动回收不再使用的内存

## 2. 用构造器确保初始化

假如没有构造器，我们会如何初始化对象呢？  
一个比较常规的想法就是为每个Class定义一个`initialize()`方法  
然后在每个对象创建时调用这个方法  
而在之后创建Object时，我们必须记得调用此方法  

但通过提供构造器，Class的设计者可以确保每个Object都得到正确的初始化  

### 2.1. 构造器的命名来源

问题：既然我们需要一个方法作为构造器，如何取名？  

考虑点：  

1. 防止与任何其他方法冲突  
2. 构造器由编译器负责，需要让编译器能够自动知道调用哪个方法

C++采用了与Class同名的方法作为构造器  
Java也继承了这种方式  

### 2.2. 构造器的定义

当我们定义了一个Class，如果我们没有定义构造器，编译器会自动为我们生成一个默认构造器  
但如果我们定义了一个构造器，编译器就不会再生成默认构造器  

因此如果我们定义了一个带参数的构造器  
那么我们之后创建Object时，就必须传入参数  

## 3. 方法重载

### 3.1. 为什么我们需要方法重载？

一般来说当我们定义了一个方法  
它所能接受的参数和处理的对象、逻辑都是固定的  
这就要求我们如果要处理不同的对象，就必须定义不同的方法  
按照一般的思路（例如C语言），我们就需要为这些对象分别分配不同的标识符  

但是对于我们实际生活中，例如“清洗”这个操作  
我们一般只会使用“清晰”+“对象”这两个信息来确定我们要进行的操作  
而不会使用“清洗类1的方法清洗”+“对象1”这种方式  

因此我们产生了一个想法就是：  
我们可以使用某一个通用的标识符，定义多个不同的方法，来处理不同的对象等  
这就是**方法重载**概念的主要来源  

### 3.2. 方法重载的基础实例

**Constructor就是一个重要例子**  

C++和Java中，构造器是强制重载方法名的另一个原因  
因为Constructor的名字已经与Class名绑定  
如果没有重载，我们就只能拥有一种构造方法了  
这显然是不满足我们的需求的  

### 3.3. 区分重载方法

由于我们重载的需求，此前用于区分方法的标识符失去了唯一性  
那我们需要一些别的部分来区分这些方法  

根据**参数**区分重载方法：  

- 参数顺序  
    实际上只有参数的顺序不同的方法，也可以被认为是不同的方法  
    *但是不建议这样做*  
- 参数类型
    重载方法的参数类型不同，此时方法可以被区分  
    *注意：传入的参数类型满足以下转换规则*  
    *存在对应时，直接取对应；存在更大类型时，向更大类型转化；仅存在类型转换时，必须传入时就进行显式转换*  
- 参数数量

或许我们会想通过返回值来区分方法  
但是我们需要回想，即使方法定义返回值，我们也不一定会使用这个返回值  
这时候我们如何区分只有返回值不同的方法呢？  
因此Java不允许通过返回值来区分方法  

## this关键字

`class`有多个对象  
当调用`class`中的方法时，我们如何知道是哪个对象调用？  
Java的解决方法是让编译器**自动传入操作对象的引用**  
但是因为是隐式传入，我们没有标识符来表示这个引用  
因此Java提供了 **`this`关键字** 来表示这个引用  

但我们同样发现，一般来说  
我们在调用同一`class`的其他方法或实例变量时，我们一般不会使用`this`关键字  
这是因为编译器会帮我们自动添加  

### this的一般用法

1. **返回调用对象的引用**  
    当我们需要返回调用对象的引用时，我们必须使用`this`关键字  
    一个相关使用场景：一条语句中对同一个对象进行多次操作  
2. **为了将自身传递给外部方法**  
    也许某个工具方法在对象所属`class`之外  
    为了将调用对象传递至外部方法，需要使用`this`关键字  
3. **在构造器中调用构造器**  
    一个`class`中定义了多个构造器  
    我们可以在一个构造器的**开头**调用另**一个**构造器  
    注意：1.只能在开头；2.只能调用一个  
4. **区分同名的方法传入参数与调用对象的实例变量**  
    当我们需要传入参数与调用对象的实例变量同名时  
    我们可以使用`this`关键字来区分  

### static含义

当我们了解了`this`关键字  
我们就可以更好理解`static`关键字的含义了  
借助我们上面的知识，我们可以如下说：  
**`static(静态)`方法就是没有`this`的方法**  

**`static`方法的特性:**  

1. 可以在没有创建`object`的情况下，直接通过`class`调用  
    *这就有点类似于全局函数的概念了*  
2. 不能调用非`static`方法和实例变量  
    *因为非`static`方法和实例变量需要`this`关键字来调用*  
    *但可以通过传入对象引用来调用或者在`static`方法中创建一个`object`来使用，但为什么不改成非`static`方法呢？*

## 清理：终结处理和垃圾回收

Java中的**垃圾回收机制**是Java的一个重要特性，也是Java的一个优势  
它负责回收无用对象占据的内存  
但是它一直有用吗？  
也存在特殊情况，即对象(并非使用`new`)获得了*特殊*的内存资源，它无法被垃圾回收机制回收  
因为垃圾回收机制只能回收由`new`创建的对象  
为了应对这种情况，Java允许在`class`中定义一个`finalize()`方法  

而我们可以同样分析一下C++采用的内存管理方式：
C++中存在析构函数的概念，是在销毁对象必须使用函数  
在一般情况下，C++程序(没有缺陷的理想情况下)中的对象一定回归销毁  
但Java中，**对象并非总是被垃圾回收**  

可以总结为以下两点：  

1. **对象可能不被垃圾回收**  
2. **垃圾回收并不等于“析构”**

### 为什么？

很有可能，只要程序没有面临存储空间使用殆尽的情况，对象所占用的空间就总是得不到释放  
若这种情况下程序执行完毕，垃圾会抽起一直没有起作用，则会随着程序的退出，直接将资源全部交还操作系统  
这个策略的目的是节省垃圾回收本身造成的开销  
*只要我不用，那就不会产生开销*  

### `finalize()`的用途何在？

显然，通过上述分析，我们知道`finalize()`方法不应该作为通用的清理方法  

这与第三点有关：

**3. 垃圾回收只与内存有关**  

即，垃圾回收器被使用的唯一原因就是为了回收程序不再使用的内存  
只要是通过Java通常做法来分配内存创建对象，那么它就可以被垃圾回收器释放  
因此特殊情况就来自于*非通常做法*的内存分配  
而这种情况主要发生在*本地方法*中  
此处不多赘述  

但不管是“垃圾回收”还是“终结”，都不一定会发生  
**如果JVM未发生内存耗尽的情形，就不会浪费时间取执行垃圾回收**  

### 终结条件

来自于`finalize()`方法的一个有趣用法 :  
用于最终发现对象中是否存在没有被适当清理的部分  

即，当对象被清理时，其应该处于某种状态，使得其内存可以被安全释放(例如打开文件的对象应该关闭文件)  
人如果没有妥善处理，程序就会存在很隐晦的缺陷  
在`finalize()`方法中设置检验和提醒可以用于检测这种情况  
尽管它并不总是被执行  
但是一旦实行，就可能据此找出问题所在！  

### 垃圾回收器如何工作

- [ ] TODO: 此处暂时还难以理解  

主要介绍了Java垃圾回收器以及其堆内存上的一些浅显的工作原理以及优化思想  

## 成员初始化

**Java尽力保证：所有变量在使用前都能得到恰当的初始化**  

Java程序中  
创建局部变量时，若未进行初始化就进行使用，会以编译时错误报告  
编译器自然可以为其赋上一个默认值，但实际上往往是程序员疏忽导致的未初始化  
要求强制提供一个初始值，更利于找出程序缺陷

示例:  

```java
public static void main(String[] args)
{
    int i ;
    i ++ ;
}
```

```bash
错误: 可能尚未初始化变量i
        i ++ ;
        ^
1 个错误
```

但与局部变量不同  
`class`的实例变量，即使没有人为的初始化，也会保证具有一个初始值  
如下：

|Data Type|Initial Value|
|:---:|:---:|
|boolean|false|
|char|'\u0000'|
|byte|0|
|short|0|
|int|0|
|long|0L|
|float|0.0f|
|double|0.0d|
|reference|null|

### 指定初始化

如果想为某个变量赋初值  
一个直接的办法就是在定义类实例变量时就进行赋值  
对于非基本类型的实例变量，也同样适用  
*注意：C++中这个操作是不合法的*  

```java
class InitialValues
{
    boolean t = true ;
    char c = 'x' ;
    byte b = 47 ;
    short s = 0xff ;
    int i = 999 ;
    long l = 1 ;
    float f = 3.14f ;
    double d = 3.14159 ;
    ExampleClass e = new ExampleClass() ;
}
```

此处，我们甚至可以通过调用某方法来提供初值  
*不过需要注意初始化的顺序*  

以上所述的方法，简单而直观  
但是限制也很明显，每个对象所具有的初值都是固定的  
当我们需要更大的灵活性时，可能需要另作考虑

## 构造器初始化

构造器初始化即适用构造器进行`object`中实例变量的初始化  
但值得注意的时，构造器初始化无法组织自动初始化的进行  
自动初始化将在构造器被调用之前发生  

### 初始化顺序

`class`内，实例变量的定义先后，决定了初始化的顺序  
此外，即使实例变量的定义散布于方法之间（即不一定位于`class`开头），也会在任何方法被调用之前得到初始化  

### 静态数据的初始化

先前所属  
`static`关键字，不止可用于修饰方法  
同样可以用于修饰实例变量  
*当然，不能应用于局部变量*  





<!-- ### UML

```plantuml
@startuml
class Person {
    - String name
    - int age
    + Person(String name, int age)
    + getName() : String
    + getAge() : int
}

Person : Person(String name, int age)
Person : getName() : String
Person : getAge() : int
@enduml
``` -->