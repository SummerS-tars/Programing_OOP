# 《Java编程思想》Chapter 7 : 复用类

Java众多优秀特性之一中，非常重要的一种就是对于代码的复用
但仅仅对于代码的复用，还不够  
需要做到更多的事情  

**重点：**  
使用类而不破坏现有的程序代码  

**方法：**  

1. **组合**  
    在新的类中产生现有的类的对象  
    只服用了现有程序代码的功能，而非其形式  
2. **继承**  
    按照现有类的类型来创建新的类  
    无需改变现有类的形式  
    采用现有类的形式并在其中添加新代码  
    大部分的工作交由编译器来完成  

---

- [1. 组合语法](#1-组合语法)
    - [1.1. 一种特殊的方法介绍：`toString()`](#11-一种特殊的方法介绍tostring)
    - [1.2. 对象初始化](#12-对象初始化)
- [2. 继承语法](#2-继承语法)
    - [2.1. 继承的语法](#21-继承的语法)
        - [2.1.1. 继承中基类的规范](#211-继承中基类的规范)
        - [2.1.2. 继承拓展行为的方式 \& `super`: 超类关键字](#212-继承拓展行为的方式--super-超类关键字)
        - [2.1.3. 初始化基类](#213-初始化基类)
- [3. 代理](#3-代理)
    - [3.1. 代理的概念](#31-代理的概念)
    - [3.2. 代理的优点](#32-代理的优点)
- [4. 组合和继承的结合使用](#4-组合和继承的结合使用)

---

## 1. 组合语法

组合技术，实际上我们已经一直在使用  
我们只需要将对象引用至于新的类中即可  

### 1.1. 一种特殊的方法介绍：`toString()`

这是一种在`Object`类中的方法  
而我们知道所有的类都继承自`Object`类  
也就是说所有的类都会有`toString()`方法  

当编译器需要一个String而我们只有一个对象时  
这个方法就会被调用  

### 1.2. 对象初始化

正如[Chapter 5对象的初始化](./20250304Chapter5.md/#6-成员初始化)中所讲  
我们对象中的类的引用类型的成员变量默认情况下会被初始化为`null`  
这很有意义，减少了很多不必要的负担  

而我们想要初始化应该如何做？  

1. 定义处就进行初始化  
2. 构造器初始化  
3. 在使用这些对象之前进行初始化（惰性初始化，和懒加载的概念相关）  
4. 使用实例初始化  

## 2. 继承语法

**继承是所有OOP语言和Java语言中不可缺少的组成部分**  
Java中，创建一个类时，总是在继承——  
除非已明确指出继承自某类  
否则就是隐式地继承自标准根类`Object`  

### 2.1. 继承的语法

组合语法符合我们之前一直的直觉  
而继承使用的则是一种特殊的语法：  
**继承过程中，我们需要先声明“新类与旧类相似”**  
这个过程中我们使用关键字 **`extends`**  

示例：  

```java
class A {
    public void foo1 { }
}

class B extends A {
    public void foo2 { } 
}
```

这里，`B`类继承自`A`类  

我们声明某个类继承自另一个类使用:  

```java
class A extends B
```

*补充：我们可以为每个类都创建一个`main()`方法，使得每个类的单元测试变得更加简便易行。只有最终指定运行的类中的`main()`方法会被执行*  

#### 2.1.1. 继承中基类的规范

为了继承，一般的规则为：  

- 将所有的数据成员指定为`private`  
- 将所有的方法指定为`public`  
- 以及目前没有接触的`protected`成员也可以借助导出类来访问  

#### 2.1.2. 继承拓展行为的方式 & `super`: 超类关键字

我们在继承的过程中，可以创建新的方法，也可以覆盖旧的方法  
但是偶尔我们在覆盖旧方法时，会需要调用旧的方法  
这时候如果直接调用方法的标识符，实际上调用新的方法，从而导致递归调用  

Java引入 **`super`** 来解决此问题，表示超类的意思  
当前类就是从超类中继承而来  
使用`super.method()`来调用超类的方法  

#### 2.1.3. 初始化基类  

我们经过上述描述，已经大致了解到继承的用途：  
使得导出类获得基类的形式  
但是，我们可能会产生疑惑：导出类产生的对象是什么样的情况？  

实际上，继承并不只是复制基类的接口  
**创建导出类的对象时，该对象包含了一个基类的子对象**  
这个子对象被包装在导出类的对象中  

那么我们对于基类子对象的正确初始化也很重要  
我们只有一种方法来对此进行保证：  
**在构造器中调用基类构造器执行初始化**  

Java会自动在在导出类的构造器中插入对基类构造器的调用  
顺序上来说，优先于导出类构造器中的行为  
形象上理解，构建过程是从基类"向外"扩散的  
示例：[SubObjectConstructor.java](../../1_code/0_2_test2/SubObjectConstructor.java)  

当然上述自动插入适用于默认构造器  
但是，如果没有默认基类构造器，或者想要调用一个带参数的基类构造器  
就必须使用`super`关键字，显式地调用基类构造器  

```java
class A
{
    A( int i )
    {
        System.out.println("A constructor") ;
    }
}

class B extends A
{
    B(int i)
    {
        super(i) ;
        System.out.println("B constructor") ;
    }

    public static void main(String[] args)
    {
        B b = new b(1) ;
    }
}
```

## 3. 代理

除去上述两种关系（组合、继承）之外，第三种关系称为 **代理**  
Java没有提供直接支持  
可以认为其为继承与组合之间的中间道路  

### 3.1. 代理的概念

我们不直接是用继承，而也不局限于使用组合  
我们将一个类的对象作为成员置于我们所要构建的类中  
同时我们在新类中暴露了该成员对象的所有方法  
*也就是说我们在新构建的类中创建方法用来代理成员对象的行为*  
*当然我们也可以从另一个角度理解：使用成员对象的行为代理我们新建类中方法所要做的行为*  

### 3.2. 代理的优点

1. 某些情况下概念上更加直观  
    例如一个系统和系统中的控制器  
    我们自然可以让系统从控制器中继承而来  
    但是实际上系统只是包含这个控制器  
2. 相较于组合控制性更强  
    本质上其实和组合相差不大  
    实际上做的事可以认为是将成员对象的接口映射至新建类中  
    在这个过程中，我们还可以对暴露的接口进行选择，只提供成员对象中的方法的某个子集  
    这使得我们使用代理时可以拥有更多的控制力  

## 4. 组合和继承的结合使用

g=