## 第 7 章：异常控制流 (ECF) (深度解析版)

**异常控制流 (ECF)** 是操作系统用来实现其核心功能的基本机制。它指的是系统中突然的控制转移，用于响应处理器状态的变化。

### 6.1 异常 (Exceptions)

异常是硬件和操作系统内核之间的接口，用于处理各种事件。

- **异常表 (Exception Table)**：CPU 启动时，操作系统会分配并初始化一个异常表。当异常发生时，CPU 会根据异常号，通过此表跳转到对应的内核**异常处理程序**。
- **异常的四种类型**：
    1. **中断 (Interrupt)**：**异步**的，由外部 I/O 设备事件触发。处理后返回到**下一条**指令。
    2. **陷阱 (Trap)**：**同步且有意**的，是执行指令的结果，主要用于实现**系统调用**。处理后返回到**下一条**指令。
    3. **故障 (Fault)**：**同步且可能被恢复**的错误，如**缺页故障**。处理后可能会**重新执行**导致故障的指令。
    4. **终止 (Abort)**：**同步且不可恢复**的致命硬件错误，直接终止程序。

### 6.2 进程与上下文切换

- **进程 (Process)**：一个正在执行的程序的实例。操作系统通过给每个进程提供两种假象来实现它：
    1. **独立的逻辑控制流**：进程感觉自己独占 CPU。
    2. **私有的地址空间**：进程感觉自己独占内存（由虚拟内存实现）。
- **上下文切换 (Context Switching)**：是实现多任务的核心机制。内核**调度器 (scheduler)** 负责在进程间切换，它保存当前进程的完整状态（**上下文**），恢复下一个进程的上下文，并将控制权交给它。

### 6.3 进程控制

- `fork()`：调用一次，返回两次。子进程获得父进程地址空间的**独立副本**（通常使用写时复制 `Copy-on-Write` 进行优化）。
- `execve()`：加载并运行一个新程序。它会**覆盖**当前进程的代码、数据和栈，但**PID 不变**。成功时**永不返回**。
- `wait()` / `waitpid()`：用于回收子进程。
    - **僵尸进程 (Zombie)**：一个已终止但其父进程尚未回收它的进程。它不执行任何代码，但仍在内核的进程表中占据一个条目。
    - **回收 (Reaping)**：父进程调用 `wait` 或 `waitpid` 来获取子进程的退出状态，并让内核彻底删除该僵尸进程。**回收子进程是父进程的责任**。
    - **孤儿进程 (Orphan)**：如果父进程先于子进程终止，这些孤儿进程会被 `init` 进程（PID 1）接管，并由 `init` 进程自动回收。

### 6.4 信号 (Signals)

信号是一种更高层的软件 ECF，它允许进程和内核通知其他进程发生了某个事件。

- **基本概念**：信号是一种**消息**，它只有一个 ID 和一个事实：它被发送了。信号不排队，对于同一种信号，多个未处理的信号通常会被合并成一个。
- **处理信号**：进程可以**忽略**、**终止**或通过安装**信号处理程序 (signal handler)** 来**捕获**信号。
- **信号处理的挑战**：
    - **并发性**：信号处理程序是一个独立的控制流，它与主程序并发执行，访问共享的全局变量时可能会产生**竞争条件**。
    - **异步信号安全**：这是编写信号处理程序时**最重要的规则**。处理程序中**只能调用异步信号安全的函数**。像 `printf`, `malloc`, `free` 这类函数都不是安全的，因为它们不可重入。
    - **被中断的系统调用**：慢速的系统调用（如 `read`）可能会被信号中断。在这种情况下，系统调用会提前返回并设置 `errno` 为 `EINTR`。健壮的程序必须检查这种情况并手动重启系统调用。

---
