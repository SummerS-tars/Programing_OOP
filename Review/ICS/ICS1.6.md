## 第 6 章：链接 (Linking) (深度解析版)

链接是将不同部分的代码和数据收集和组合成一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。它使得分离编译成为可能，是构建大型软件项目的基石。

### 5.1 链接器的角色与任务

链接器的两个核心任务是**符号解析**和**重定位**。

1. **符号解析 (Symbol Resolution)**：
    程序中定义和引用的**符号 (Symbol)**，主要指函数和全局变量。链接器的工作就是确保程序中每一个对符号的引用，都有一个唯一、确切的定义与之对应。链接器处理三种类型的符号：
    - **全局符号 (Global Symbols)**：由当前模块定义，并能被其他模块引用。例如，非 `static` 的 C 函数和全局变量。
    - **外部符号 (External Symbols)**：由其他模块定义，但在当前模块中被引用。例如，在代码中调用 `printf` 函数。
    - **本地符号 (Local Symbols)**：仅在当前模块内部定义和引用。例如，带有 `static` 属性的 C 函数和全局变量，它们对其他模块是不可见的。

2. **重定位 (Relocation)**：
    编译器和汇编器生成从地址 0 开始的代码和数据节。链接器将所有模块的同类型节合并，并为每个节和符号分配最终的**运行时内存地址**。接着，它会修改代码和数据中对这些符号的所有引用，使其指向正确的运行时地址。这个“修补”引用的过程就是重定位。

### 5.2 核心机制：强弱符号与解析规则

当链接器遇到多个模块定义了同名的全局符号时，它会使用以下规则来决定使用哪个定义。这个机制是 C/C++ 中一个常见且隐蔽的 bug 来源。

- **强符号 (Strong)**: 函数和已初始化的全局变量。
- **弱符号 (Weak)**: 未初始化的全局变量。

**链接器规则**：

1. **不允许有多个同名的强符号**。这会直接导致链接错误。
2. 若存在一个强符号和多个同名弱符号，链接器会**选择强符号的定义**。
3. 若存在多个同名弱符号，链接器会**任意选择其中一个**。

> **编程陷阱**：规则 2 和 3 意味着链接器会默默地处理多重定义的全局变量，而不会报错。这可能导致一个模块意外地修改了另一个模块的变量，造成难以调试的错误。**最佳实践是：尽量避免使用全局变量；如果必须使用，请进行初始化，使其成为强符号**。

### 5.3 实践：静态库与动态库

- **静态库 (Static Libraries)**
    - 静态库 (`.a` 文件) 是将一组相关的 `.o` 文件打包成一个单一文件。在链接时，链接器只从中**选择并复制**程序实际需要的模块到最终的可执行文件中。
    - **命令行顺序的重要性**：链接器按顺序扫描命令行中的文件。它维护一个未解析符号的列表。因此，**库文件必须放在命令行的末尾**。例如 `gcc main.o libmylib.a` 是正确的，而 `gcc libmylib.a main.o` 可能会因为在处理 `main.o` 之前找不到符号而失败。

- **动态库 (Shared Libraries)**
    - 为了解决静态库中代码重复和更新困难的问题，现代系统广泛使用动态库 (`.so` 文件)。
    - **动态链接**：程序在链接时，不会复制库代码，而只记录一个对库的引用。在程序**加载时或运行时**，**动态链接器** (`ld-linux.so`) 会将库加载到内存，并完成最终的重定位。
    - **核心优势**：极大地节省了磁盘空间和内存（多个进程可以共享同一份库的物理内存副本），并且更新库时无需重新编译和链接应用程序。

### 5.4 高级技术：位置无关代码 (PIC)

为了让单个共享库副本能被加载到任意内存地址并被多进程共享，库代码必须编译为**位置无关代码 (Position-Independent Code - PIC)**。

- **实现原理**：编译器避免在代码中生成任何绝对地址。
    - **全局数据访问**：通过一个称为**全局偏移量表 (GOT)** 的数据结构间接访问。
    - **函数调用**：通过**过程链接表 (PLT)** 和 GOT 协同实现**延迟绑定 (lazy binding)**，即函数地址只在第一次被调用时才被解析，这可以加速程序的启动。

---
