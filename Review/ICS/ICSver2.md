# ICS

---

- [1. 第 1 章：计算机系统漫游](#1-第-1-章计算机系统漫游)
    - [1.1. 信息就是“位+上下文”](#11-信息就是位上下文)
    - [1.2. 程序的翻译过程](#12-程序的翻译过程)
    - [1.3. 系统的硬件组成](#13-系统的硬件组成)
    - [1.4. “hello” 程序的执行之旅](#14-hello-程序的执行之旅)
    - [1.5. 存储器层次结构](#15-存储器层次结构)
    - [1.6. 操作系统的角色](#16-操作系统的角色)
    - [1.7. 系统知识的重要性 (The “Great Realities”)](#17-系统知识的重要性-the-great-realities)
- [2. 第 2 章：信息的表示和处理 (进阶版 v2.0)](#2-第-2-章信息的表示和处理-进阶版-v20)
    - [2.1. 信息的二进制表示与字节序](#21-信息的二进制表示与字节序)
    - [2.2. 位运算与移位运算](#22-位运算与移位运算)
    - [2.3. 整数表示](#23-整数表示)
    - [2.4. 整数的扩展与截断](#24-整数的扩展与截断)
    - [2.5. 整数运算与溢出](#25-整数运算与溢出)
    - [2.6. 浮点数表示 (IEEE 754)](#26-浮点数表示-ieee-754)
    - [2.7. 浮点数舍入与运算](#27-浮点数舍入与运算)
- [3. 第 3 章：程序的机器级表示 (深度解析版)](#3-第-3-章程序的机器级表示-深度解析版)
    - [3.1. 基础：寄存器、操作数与数据移动](#31-基础寄存器操作数与数据移动)
        - [3.1.1. 寄存器 (Registers)](#311-寄存器-registers)
        - [3.1.2. 操作数 (Operands)](#312-操作数-operands)
        - [3.1.3. 数据移动 (`mov`) 与栈操作 (`push`/`pop`)](#313-数据移动-mov-与栈操作-pushpop)
    - [3.2. 核心：地址计算与 `leaq`](#32-核心地址计算与-leaq)
        - [3.2.1. 寻址模式 (Addressing Modes)](#321-寻址模式-addressing-modes)
        - [3.2.2. `leaq` 指令的威力](#322-leaq-指令的威力)
    - [3.3. 控制流：条件码与跳转](#33-控制流条件码与跳转)
        - [3.3.1. 条件码 (Condition Codes)](#331-条件码-condition-codes)
        - [3.3.2. 设置与读取条件码](#332-设置与读取条件码)
        - [3.3.3. `switch` 语句和跳转表](#333-switch-语句和跳转表)
    - [3.4. 过程调用：栈帧与寄存器惯例](#34-过程调用栈帧与寄存器惯例)
        - [3.4.1. 栈帧 (Stack Frame)](#341-栈帧-stack-frame)
        - [3.4.2. 寄存器使用惯例](#342-寄存器使用惯例)
        - [3.4.3. 递归 (Recursion)](#343-递归-recursion)
- [4. 第 4 章：程序的机器级表示：结构化与聚合数据 (深度解析版)](#4-第-4-章程序的机器级表示结构化与聚合数据-深度解析版)
    - [4.1. 数组 (Arrays)](#41-数组-arrays)
    - [4.2. 结构体 (Structures)](#42-结构体-structures)
    - [4.3. 联合体 (Unions)](#43-联合体-unions)
- [5. 第 5 章：程序的机器级表示：高级主题与安全](#5-第-5-章程序的机器级表示高级主题与安全)
    - [5.1. 缓冲区溢出 (Buffer Overflow)](#51-缓冲区溢出-buffer-overflow)
    - [5.2. 对抗缓冲区溢出攻击的机制](#52-对抗缓冲区溢出攻击的机制)
    - [5.3. 返回导向编程 (Return-Oriented Programming - ROP)](#53-返回导向编程-return-oriented-programming---rop)
- [6. 第 6 章：链接 (Linking) (深度解析版)](#6-第-6-章链接-linking-深度解析版)
    - [6.1. 链接器的角色与任务](#61-链接器的角色与任务)
    - [6.2. 核心机制：强弱符号与解析规则](#62-核心机制强弱符号与解析规则)
    - [6.3. 实践：静态库与动态库](#63-实践静态库与动态库)
    - [6.4. 高级技术：位置无关代码 (PIC)](#64-高级技术位置无关代码-pic)
- [7. 第 7 章：异常控制流 (ECF) (深度解析版)](#7-第-7-章异常控制流-ecf-深度解析版)
    - [7.1. 异常 (Exceptions)](#71-异常-exceptions)
    - [7.2. 进程与上下文切换](#72-进程与上下文切换)
    - [7.3. 进程控制](#73-进程控制)
    - [7.4. 信号 (Signals)](#74-信号-signals)
- [8. 第 8 章：虚拟内存 (Virtual Memory) (深度解析版)](#8-第-8-章虚拟内存-virtual-memory-深度解析版)
    - [8.1. 核心思想与动机](#81-核心思想与动机)
    - [8.2. 地址翻译 (Address Translation)](#82-地址翻译-address-translation)
    - [8.3. 加速翻译：TLB (Translation Lookaside Buffer)](#83-加速翻译tlb-translation-lookaside-buffer)
    - [8.4. 多级页表 (Multi-Level Page Tables)](#84-多级页表-multi-level-page-tables)
- [9. 第 9 章：存储器层次结构与缓存 (Memory Hierarchy \& Caches)](#9-第-9-章存储器层次结构与缓存-memory-hierarchy--caches)
    - [9.1. 存储技术与 CPU-内存差距](#91-存储技术与-cpu-内存差距)
    - [9.2. 局部性原理 (Principle of Locality)](#92-局部性原理-principle-of-locality)
    - [9.3. 缓存的核心概念](#93-缓存的核心概念)
    - [9.4. 编写缓存友好的代码](#94-编写缓存友好的代码)

---

## 1. 第 1 章：计算机系统漫游

这一章将带领我们对计算机系统进行一次整体的漫游。我们将通过一个简单的 “hello, world” 程序，了解它在系统中的生命周期——从源代码到可执行文件，再到最终在屏幕上显示结果的全过程，从而对系统中的硬件、操作系统和各个组件如何协同工作有一个宏观的认识。

### 1.1. 信息就是“位+上下文”

计算机系统中所有的信息，无论是磁盘文件、内存中的程序、用户数据还是网络上传输的数据，本质上都是由一串比特（bits）来表示的。我们赋予这些比特序列不同的**上下文（context）**，才能解读它们的真实含义。

- **示例**：一个简单的 `hello.c` 程序。
    - 对于程序员来说，`hello.c` 是一个由 ASCII 字符组成的文本文件。
    - 然而，在系统内部，这个文件被表示为一串 0 和 1 的序列。
    - 当我们编译这个程序后，得到的 `hello` 可执行文件是另一串比特序列，但它的上下文已经变为**机器语言指令**，可以被处理器直接理解和执行。

```c
// hello.c 源代码
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

### 1.2. 程序的翻译过程

一个C语言程序需要通过**编译系统**的四个阶段，才能从人类可读的源代码转变为机器可执行的代码。

1. **预处理 (Preprocessing)**：预处理器 (`cpp`) 根据以 `#` 开头的命令（如 `#include <stdio.h>`）修改原始C程序，生成一个 `.i` 文件。
2. **编译 (Compilation)**：编译器 (`cc1`) 将文本文件 `hello.i` 翻译成汇编语言程序 `hello.s`。汇编语言是机器语言的文本表示。
3. **汇编 (Assembly)**：汇编器 (`as`) 将 `hello.s` 翻译成机器语言指令，并将这些指令打包成一种称为**可重定位目标程序 (relocatable object program)** 的格式，保存在 `.o` 文件中。
4. **链接 (Linking)**：链接器 (`ld`) 负责将程序中引用的库函数（如 `printf`）的代码合并到我们的 `.o` 文件中，最终生成一个完整的、可以加载到内存中执行的**可执行目标文件 (executable object file)**。

### 1.3. 系统的硬件组成

为了理解程序是如何运行的，我们需要了解一个典型系统的硬件构成。

- **总线 (Buses)**：贯穿整个系统的电子管道，负责在各个组件之间传递信息字节。
- **I/O 设备 (I/O Devices)**：是系统与外部世界的联系通道，如键盘、鼠标、显示器和磁盘。磁盘是用来长期存储可执行程序和数据的。
- **主存 (Main Memory)**：一个临时的存储设备，用于在处理器执行程序时存放程序和其处理的数据。从物理上看，主存是由一组**动态随机存取存储器 (DRAM)** 芯片组成的。
- **处理器 (CPU)**：中央处理单元，是解释和执行存储在主存中指令的引擎。
    - **程序计数器 (PC)**：CPU 核心的一个寄存器，它指向主存中下一条要执行的指令的地址。
    - **寄存器堆 (Register File)**：一个由少量寄存器组成的存储设备。
    - **算术/逻辑单元 (ALU)**：负责执行算术和逻辑运算。

### 1.4. “hello” 程序的执行之旅

当我们让系统执行 `hello` 程序时，发生了以下一系列事件：

1. **输入命令**：我们在键盘上输入字符串 `./hello`，shell 程序将字符逐一读入寄存器，再存放到主存中。
2. **加载程序**：当我们在键盘上敲下回车键后，shell 程序知道我们结束了命令输入。它会执行一系列指令来加载可执行的 `hello` 文件。这些指令将 `hello` 目标文件中的代码和数据从磁盘复制到主存。
3. **执行与输出**：一旦 `hello` 程序的代码和数据被加载到主存，处理器就开始执行 `main` 程序中的机器语言指令。这些指令将 "hello, world\n" 字符串中的字节从主存复制到寄存器堆，再从寄存器堆复制到显示设备，最终我们就在屏幕上看到了输出。

### 1.5. 存储器层次结构

系统中的存储设备被组织成一个层次结构，从上到下，设备的访问速度越来越慢，容量越来越大，每字节的造价也越来越便宜。

- **L0: 寄存器 (Registers)**
- **L1: L1 缓存 (SRAM)**
- **L2: L2 缓存 (SRAM)**
- **L3: L3 缓存 (SRAM)**
- **L4: 主存 (DRAM)**
- **L5: 本地二级存储 (本地磁盘)**
- **L6: 远程二级存储 (分布式文件系统, Web服务器)**

**缓存 (Caching)** 是这个层次结构的核心思想。上一层的存储器作为其下一层存储器的高速缓存。通过这种方式，系统可以获得巨大的存储容量，同时又能以极快的速度访问数据，仿佛拥有一个又大又快的存储器。

### 1.6. 操作系统的角色

**操作系统 (Operating System)** 是应用程序和硬件之间的中间层软件，它有两个主要功能：(1) 防止硬件被失控的应用程序滥用；(2) 向应用程序提供简单一致的机制来控制复杂的低级硬件设备。

为实现这两个功能，操作系统提出了几个关键的抽象概念：

- **进程 (Process)**：对处理器、主存和 I/O 设备的抽象。它是一个正在运行的程序的实例，为程序提供一种假象，仿佛它独占地使用系统资源。多个进程可以并发运行，由操作系统内核进行上下文切换。
- **虚拟内存 (Virtual Memory)**：对主存和磁盘的抽象。它为每个进程提供一个私有的、完整的地址空间，使得每个进程都感觉自己独占了主存。
- **文件 (File)**：对 I/O 设备的抽象，将所有 I/O 设备（如磁盘、键盘、网络）都视为字节序列。

### 1.7. 系统知识的重要性 (The “Great Realities”)

作为程序员，为什么需要理解计算机系统的工作原理？

1. **整数和浮点数并非真实世界的数字**：计算机中的算术运算受到表示范围和精度的限制，可能会出现溢出或舍入误差，这与数学上的整数和实数运算不同。
2. **你需要了解汇编**：虽然我们很少直接编写汇编代码，但理解汇编是理解程序底层行为、调试疑难杂症和进行性能优化的关键。
3. **内存很重要**：内存不是无限的，必须小心管理。内存引用错误（如越界访问）非常隐蔽且有害。此外，缓存和虚拟内存对程序性能有巨大影响。
4. **性能不仅仅是渐进复杂度**：算法的时间复杂度很重要，但常数因子、编译和执行方式、内存访问模式等同样会极大地影响程序性能。
5. **计算机不只是执行程序**：它们还需要与外部世界进行数据交互（I/O），并通过网络进行通信，这些都带来了并发、可靠性和兼容性等系统级挑战。

---

## 2. 第 2 章：信息的表示和处理 (进阶版 v2.0)

本章的核心是理解计算机如何用二进制位来表示数字（包括整数和浮点数），以及如何对这些表示进行运算。这是后续所有章节的基础。

### 2.1. 信息的二进制表示与字节序

计算机中所有的数据都由比特（bits）构成，通常每 8 个比特组成一个**字节 (Byte)**。对于跨越多个字节的数据类型（如 `int`, `double`），其在内存中的字节排列顺序是一个关键概念，这被称为**字节序 (Byte Ordering)**。

- **小端法 (Little-Endian)**：数据的**最低有效字节 (Least Significant Byte, LSB)** 存放在**最低**的内存地址处。**x86-64 架构使用小端法**。
- **大端法 (Big-Endian)**：数据的**最高有效字节 (Most Significant Byte, MSB)** 存放在**最低**的内存地址处。常用于网络传输协议（即网络字节序）。

> 理解字节序对于网络编程和跨平台数据文件分析至关重要。

### 2.2. 位运算与移位运算

C 语言提供了一套强大的位运算符，用于直接操作数据的位模式。

- **位逻辑运算**：包括按位与 `&`、按位或 `|`、按位异或 `^` 和按位取反 `~`。这些运算常用于掩码操作，以隔离、设置或清除特定的位。
- **移位运算**：
    - **左移 `<<`**：`x << k` 将 `x` 左移 k 位，右侧补 0。
    - **右移 `>>`**：分为两种类型：
        - **逻辑右移**：在左侧补 0。用于**无符号数**。
        - **算术右移**：在左侧补**符号位**的副本。用于**有符号数**。

> **注意**：逻辑运算符 `&&` 和 `||` 存在“短路求值”特性，而位运算符 `&` 和 `|` 则没有。混用这两者是 C 语言中一个常见的编程错误。

### 2.3. 整数表示

- **无符号整数 (Unsigned)**：直接使用二进制表示法，其值为 $B2U(X) = \sum_{i=0}^{w-1} x_i \cdot 2^i$。
- **有符号整数 (Signed)**：现代计算机普遍采用**补码 (Two's Complement)** 表示法。
    - **优点**：补码使得计算机可以用同样的加法器硬件来处理有符号数和无符号数的加法，极大地简化了 CPU 设计。
    - **表示**：其值为 $B2T(X) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$。最高位是**符号位**。
    - **不对称范围**：一个 w 位的有符号数范围为 $[-2^{w-1}, 2^{w-1}-1]$。最小负数 `TMin` 没有与之对应的正数。因此 `abs(TMin)` 的结果仍为 `TMin`，这是一个潜在的 bug 源头。
    - **类型转换**：在 C 语言中，当有符号数和无符号数混合运算时，**有符号数会隐式转换为无符号数**。这会导致一些违反直觉的比较结果，例如 `-1 > 0U` 的结果为真。

### 2.4. 整数的扩展与截断

- **扩展 (Promotion)**：从一个较小的数据类型转换为较大的数据类型时，无符号数进行**零扩展**（高位补 0），有符号数进行**符号扩展**（高位补充符号位）。
- **截断 (Truncation)**：从一个较大的数据类型转换为较小的数据类型时，直接丢弃高位比特。

### 2.5. 整数运算与溢出

- **无符号溢出**：当结果超出无符号数的表示范围时，会发生**回环 (wrap-around)**，其行为是明确定义的，相当于对 $2^w$ 取模。
- **有符号溢出**：当结果超出了有符号数的表示范围时发生（如两个正数相加得到负数）。在 C 语言标准中，有符号溢出是**未定义行为 (undefined behavior)**，程序员不应依赖其任何特定行为。

### 2.6. 浮点数表示 (IEEE 754)

浮点数采用 $V = (-1)^s \times M \times 2^E$ 的形式来表示小数。一个浮点数的位表示分为三个字段：

- 1 位的**符号字段 `s`**。
- k 位的**阶码字段 `exp`**。
- n 位的**小数字段 `frac`**。

根据 `exp` 的值，编码被分为三种情况：

1. **规格化的 (Normalized)**
    - **条件**：`exp` 的位模式既不全为 0，也不全为 1。
    - **阶码**：$E = exp - Bias$。其中 $Bias = 2^{k-1} - 1$ 是一个偏置值。
    - **尾数**：$M = 1 + frac$。`frac` 是二进制小数点右边的部分，小数点左边的 1 是**隐含的**，不占用位。这是表示浮点数的最常见情况。

2. **非规格化的 (Denormalized)**
    - **条件**：`exp` 的位模式全为 0。
    - **目的**：用于表示非常接近 0 的数，以及 0 本身。
    - **阶码**：$E = 1 - Bias$ (注意不是 `-Bias`)。
    - **尾数**：$M = frac$。此时，尾数没有隐含的 1。

3. **特殊值 (Special)**
    - **条件**：`exp` 的位模式全为 1。
    - 当 `frac` 全为 0 时，表示**无穷大 (infinity)**。
    - 当 `frac` 不为 0 时，表示 **“不是一个数” (NaN, Not-a-Number)**，用于表示如 $\sqrt{-1}$ 或 $\infty - \infty$ 这样的无效运算结果。

### 2.7. 浮点数舍入与运算

- **舍入 (Rounding)**：由于表示精度有限，浮点运算的结果几乎总是被舍入的。IEEE 754 定义了四种舍入模式，系统的默认模式是**向偶数舍入 (Round-to-even)**。
    - **规则**：将数字向上或向下舍入，使得结果的最低有效数字是偶数。例如，将以下数字舍入到最近的整数：
        - `1.4` $\rightarrow$ `1`
        - `1.6` $\rightarrow$ `2`
        - `1.5` $\rightarrow$ `2` (2 是偶数)
        - `2.5` $\rightarrow$ `2` (2 是偶数)
    - **优点**：在统计上是无偏的，避免了在大量计算中系统性地向上或向下舍入造成的累积误差。

- **浮点运算**：
    - **步骤**：先计算出理想的精确结果，然后将其舍入到目标浮点格式所能表示的最接近的值。
    - **代数性质**：由于舍入的存在，浮点运算不满足常规的代数定律。例如，加法和乘法**不满足结合律**。`(a+b)+c` 不一定等于 `a+(b+c)`。这对编译器优化和要求高精度的科学计算带来了挑战。

---

## 3. 第 3 章：程序的机器级表示 (深度解析版)

本章的目标是让你能够阅读和理解由 C 编译器生成的 x86-64 汇编代码。这不仅是理解“程序如何工作”的基础，也是进行高级性能优化和安全分析的必备技能。

### 3.1. 基础：寄存器、操作数与数据移动

#### 3.1.1. 寄存器 (Registers)

寄存器是 CPU 中最核心、速度最快的存储单元。x86-64 架构提供了 16 个 64 位的通用目的寄存器。**理解每个寄存器的惯例用途至关重要**。

- **通用寄存器与主要用途**：
    - `%rax`: **返回值**。函数执行完毕后，返回值通常存放在这里。
    - `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`: **前六个函数参数**。按照从左到右的顺序依次使用。
    - `%rsp`: **栈指针**。它始终指向运行时栈的栈顶，地址随着 `push` 和 `pop` 操作而改变。
    - `%rbp`: **基址/帧指针 (可选)**。可以用来标记当前栈帧的起点，方便访问局部变量和参数。
    - `%r10`, `%r11`: **调用者保存**的临时寄存器。
    - `%rbx`, `%r12`-%r15: **被调用者保存**的临时寄存器。

#### 3.1.2. 操作数 (Operands)

一条汇编指令的操作数指定了要操作的数据来源和存放结果的目标。

- **立即数 (Immediate)**: 常量值，如 `$0x100`。
- **寄存器 (Register)**: 16 个通用寄存器之一，如 `%rax`。
- **内存引用 (Memory)**: 访问内存中的数据，其地址通过寻址模式计算得出。

#### 3.1.3. 数据移动 (`mov`) 与栈操作 (`push`/`pop`)

- `movq S, D`: 这是最基本的数据移动指令，将源 `S` 的值复制到目标 `D`。
    - **核心限制**: x86-64 **不支持单条指令完成内存到内存的传送**。这是一个基础但重要的架构约束，任何内存间的数据复制都必须通过一个寄存器作为中介来完成。
- `pushq src`: 将栈指针 `%rsp` 向下（低地址）移动 8 个字节，然后将 `src` 的值写入新的栈顶地址。
- `popq dst`: 从当前栈顶地址读取值到 `dst`，然后将栈指针 `%rsp` 向上（高地址）移动 8 个字节。

### 3.2. 核心：地址计算与 `leaq`

#### 3.2.1. 寻址模式 (Addressing Modes)

掌握寻址模式是阅读汇编代码的关键。x86-64 最通用的寻址模式是 $D(R_b, R_i, S)$，它涵盖了所有其他简单形式。

- **计算公式**: 地址 = $D + Reg[R_b] + Reg[R_i] \cdot S$
- `D`: 常量位移
- `R_b`: 基址寄存器
- `R_i`: 变址寄存器
- `S`: 比例因子 (只能是 1, 2, 4, 8)

例如，`8(%rbp)` 是 $8 + Reg[\%rbp]$，而 `(%rax)` 是 $Reg[\%rax]$。

#### 3.2.2. `leaq` 指令的威力

`leaq src, dst` (Load Effective Address) 是 x86-64 中最巧妙的指令之一。

- **核心功能**: 它计算出 `src` 操作数所代表的**地址**，并将这个地址值本身存入 `dst` 寄存器。它**从不访问内存**。
- **双重用途**:
    1. **计算地址**: 用于获取指针，如 `leaq 8(%rbp), %rax` 就是将 `%rbp+8` 这个地址加载到 `%rax`。
    2. **高效算术**: 编译器常用它来执行简单的算术运算。例如，`leaq (%rdi, %rdi, 4), %rax` 可以用一条指令计算 `x + 4*x`，即 `5*x` (假设 `x` 在 `%rdi` 中)。

### 3.3. 控制流：条件码与跳转

#### 3.3.1. 条件码 (Condition Codes)

CPU 内部有四个极其重要的单个 bit 的条件码寄存器，它们是实现所有条件分支的基础。

- `ZF` (零标志): 当运算结果为 0 时设置。
- `SF` (符号标志): 当运算结果为负数时设置。
- `CF` (进位标志): 用于无符号运算，当最高位产生进位时设置。
- `OF` (溢出标志): 用于有符号运算，当发生正或负溢出时设置。

#### 3.3.2. 设置与读取条件码

- `cmpq b, a` 和 `testq b, a` 是专门用来设置条件码的指令，它们不修改任何其他寄存器。`cmp` 基于减法 `a-b` 设置，`test` 基于位与 `a&b` 设置。`testq %rax, %rax` 是检查 `%rax` 是否为 0 的常用方法。
- `setX dst` 和 `jX target` 指令根据条件码的状态来行动。`setX` 指令将一个字节设置为 0 或 1，而 `jX` 指令决定是否跳转。所有 C 语言的 `if`、`while`、`for` 最终都由这些指令实现。

#### 3.3.3. `switch` 语句和跳转表

对于密集的 `switch` 语句，编译器会生成一个**跳转表 (Jump Table)**。这是一个数组，存储了每个 `case` 代码块的地址。程序通过一次数组查找和一次**间接跳转** (`jmp *target`) 直接到达目标代码，这比一长串 `if-else` 判断高效得多。

### 3.4. 过程调用：栈帧与寄存器惯例

#### 3.4.1. 栈帧 (Stack Frame)

每次函数调用，都会在栈上为其分配一个区域，称为**栈帧**。这个栈帧包含了函数执行所需的所有局部状态：传递给该函数的参数、返回地址、保存的寄存器值以及局部变量。

#### 3.4.2. 寄存器使用惯例

这是 x86-64 过程调用中最核心的约定，它确保了函数调用不会意外地破坏调用者的状态。

- **参数传递**: 前六个整型/指针参数通过 `%rdi, %rsi, %rdx, %rcx, %r8, %r9` 传递。
- **调用者保存 (Caller-Saved)**: 包括**所有参数寄存器**以及 `%rax`, `%r10`, `%r11`。**规则**: 当函数 P 调用函数 Q 时，P 必须假定 Q 会修改这些寄存器。如果 P 在调用 Q 之后还需要用到这些寄存器的值，P **必须在调用前**将它们保存到自己的栈帧中。
- **被调用者保存 (Callee-Saved)**: 包括 `%rbx, %rbp, %r12-%15`。**规则**: 函数 Q **必须保证**在它返回时，这些寄存器的值与它被调用时完全相同。如果 Q 需要使用这些寄存器，它**必须在开头**将它们的原始值压栈保存，并在返回前恢复它们。

理解这个惯例是调试涉及函数调用的汇编代码的关键。

#### 3.4.3. 递归 (Recursion)

递归函数的实现与普通函数调用并无二致。每一次递归调用都会创建一个全新的、独立的栈帧。因此，不同调用层次之间的局部变量和状态互不干扰，使得递归能够正确工作。

---

## 4. 第 4 章：程序的机器级表示：结构化与聚合数据 (深度解析版)

本章我们将 C 语言中的数据结构与其底层的汇编实现联系起来，重点关注内存布局、地址计算和数据对齐。

### 4.1. 数组 (Arrays)

- **基本原则与指针运算**：
    - C 语言中的数组被定义为一个**连续的内存块**，其总大小为 `$L \times \text{sizeof}(T)$`，其中 `$L$` 是数组长度，$T$ 是元素类型。
    - 数组标识符（如 `a`）本身可以被看作是指向数组第一个元素 `a[0]` 的指针。
    - 因此，对数组成员的访问 `a[i]` 在底层被编译器翻译为指针运算：计算地址 $A + i \cdot \text{sizeof}(T)$，然后访问该地址的内存。

- **多维数组 (Nested Arrays)**：
    - **行主序 (Row-Major Order)**：这是 C 语言中一个至关重要的存储规则。对于一个声明为 `T A[R][C]` 的二维数组，它在内存中是按行连续存放的。即先存放第 0 行的所有 `C` 个元素，然后是第 1 行，以此类推。
    - **地址计算**：基于行主序，访问元素 `A[i][j]` 的地址计算公式为：$\&A[i][j] = A + (i \cdot C + j) \cdot \text{sizeof}(T)$。理解这个公式有助于分析代码的**空间局部性**。按行遍历（改变 `j`）的步长为 1，缓存友好；而按列遍历（改变 `i`）的步长为 `C`，可能会导致严重的缓存性能问题。

- **多级数组 (Multi-level Arrays) vs. 多维数组**：
    - **本质区别**：多维数组是一个大的、连续的内存块。而多级数组（例如通过 `int **a` 创建）是一个**指针数组**，每个指针指向一个独立的、可能不连续的内存块。
    - **访问开销**：访问多维数组元素 `A[i][j]` 只需要一次内存读取（在地址计算之后）。而访问多级数组元素 `A[i][j]` **至少需要两次内存读取**：第一次是读取指针 `A[i]` 的值，第二次才是根据这个指针去访问目标数据。因此，在性能上，多维数组通常更优。

### 4.2. 结构体 (Structures)

结构体将不同类型的数据聚合到一个对象中。其在内存中的布局遵循严格的**对齐 (Alignment)** 规则。

- **数据对齐的核心原则**：
    现代处理器为了提高访存效率，要求任何大小为 `$K$` 字节的原始数据类型的地址必须是 $K$ 的倍数。例如，一个 `int` (4字节) 变量的地址应该是 4 的倍数，一个 `double` (8字节) 变量的地址应该是 8 的倍数。

- **结构体的对齐规则**：
    1. **字段对齐**：结构体中的每个字段的存放位置，其相对于结构体起始地址的偏移量，必须是该字段自身对齐要求（通常是其大小）的整数倍。为了满足这个要求，编译器可能会在字段之间插入不使用的空间，即**内部填充 (internal padding)**。
    2. **整体对齐**：一个结构体的对齐要求等于其内部**最大字段**的对齐要求。例如，一个结构体只要包含 `double` 成员，那么该结构体整体的起始地址就必须是 8 的倍数。
    3. **大小对齐**：结构体的总大小必须是其**整体对齐要求**（由规则 2 决定）的整数倍。如果当前所有字段大小之和不满足，编译器会在结构体的末尾插入**尾部填充 (tail padding)**。这条规则是为了确保在创建结构体数组时，数组中的每一个元素都能满足其对齐要求。

- **优化策略**：在定义结构体时，将**占用空间大的字段放在前面**，通常可以减少填充所带来的空间浪费。

### 4.3. 联合体 (Unions)

- **内存共享**：联合体 (Union) 的所有成员共享同一块内存空间，其大小由其**最大的成员**的大小决定。
- **用途**：联合体的一个主要用途是，允许你用不同的数据类型来解释同一段内存，这在需要直接访问数据的位模式时非常有用，但也是一种潜在的不安全操作。

---

## 5. 第 5 章：程序的机器级表示：高级主题与安全

本章探讨一些更高级的话题，重点是现代安全领域最核心的挑战之一：缓冲区溢出。

### 5.1. 缓冲区溢出 (Buffer Overflow)

- **定义**：当程序向一个缓冲区（通常是栈上的字符数组）写入的数据超出了其边界时，就会发生缓冲区溢出。
- **栈破坏 (Stack Smashing)**：由于栈上存放着局部变量、保存的寄存器状态以及**返回地址**，缓冲区溢出可能会覆盖这些关键数据。最危险的情况是，攻击者可以精心构造输入，精确地覆盖函数的**返回地址**。
- **代码注入攻击**：
    1. 攻击者将一段恶意的机器代码（称为 *shellcode*）作为输入字符串的一部分。
    2. 通过溢出，他们用这段恶意代码的起始地址来覆盖原始的返回地址。
    3. 当函数执行 `ret` 指令时，程序不会返回到调用者，而是会跳转到攻击者注入的代码并执行它，从而获得系统的控制权。

### 5.2. 对抗缓冲区溢出攻击的机制

为了应对这类攻击，现代系统采取了多种防御措施。

1. **栈随机化 (Stack Randomization)**
    - 也称为**地址空间布局随机化 (ASLR)**，程序每次运行时，栈的起始地址都是随机的。
    - 这使得攻击者难以预测他们注入的代码的准确地址，从而让攻击变得非常困难。

2. **栈金丝雀/栈保护 (Stack Canaries)**
    - 编译器在函数的栈帧中，在任何缓冲区和返回地址之间，放置一个特殊的随机值，称为 **“金丝雀” (canary)** 。
    - 在函数返回之前，程序会检查这个金丝雀的值是否被改变。如果被改变，说明发生了缓冲区溢出，程序会立即终止，而不是执行被篡改的返回地址。

3. **非可执行内存 (Non-Executable Memory)**
    - 现代处理器允许将内存区域标记为“可读”、“可写”或“可执行”。
    - 通过将栈内存区域标记为不可执行，即使攻击者成功注入了代码，CPU 也会拒绝执行该代码，从而阻止了攻击。

### 5.3. 返回导向编程 (Return-Oriented Programming - ROP)

ROP 是一种更高级的攻击技术，旨在绕过“非可执行内存”的防御。

- **核心思想**：攻击者不注入新代码，而是在现有代码（如标准库 `libc`）中寻找一系列有用的、以 `ret` 指令结尾的短指令序列，这些序列被称为 **“小工具” (gadgets)** 。
- **攻击方式**：攻击者通过缓冲区溢出，用一连串精心挑选的 gadget 的地址来覆盖栈。当第一个 `ret` 指令执行时，它会跳转到第一个 gadget；当这个 gadget 执行完毕后的 `ret` 又会从栈上弹出下一个 gadget 的地址并跳转...如此往复，将这些小程序片段串联起来，执行复杂的恶意操作。

---

## 6. 第 6 章：链接 (Linking) (深度解析版)

链接是将不同部分的代码和数据收集和组合成一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。它使得分离编译成为可能，是构建大型软件项目的基石。

### 6.1. 链接器的角色与任务

链接器的两个核心任务是**符号解析**和**重定位**。

1. **符号解析 (Symbol Resolution)**：
    程序中定义和引用的**符号 (Symbol)**，主要指函数和全局变量。链接器的工作就是确保程序中每一个对符号的引用，都有一个唯一、确切的定义与之对应。链接器处理三种类型的符号：
    - **全局符号 (Global Symbols)**：由当前模块定义，并能被其他模块引用。例如，非 `static` 的 C 函数和全局变量。
    - **外部符号 (External Symbols)**：由其他模块定义，但在当前模块中被引用。例如，在代码中调用 `printf` 函数。
    - **本地符号 (Local Symbols)**：仅在当前模块内部定义和引用。例如，带有 `static` 属性的 C 函数和全局变量，它们对其他模块是不可见的。

2. **重定位 (Relocation)**：
    编译器和汇编器生成从地址 0 开始的代码和数据节。链接器将所有模块的同类型节合并，并为每个节和符号分配最终的**运行时内存地址**。接着，它会修改代码和数据中对这些符号的所有引用，使其指向正确的运行时地址。这个“修补”引用的过程就是重定位。

### 6.2. 核心机制：强弱符号与解析规则

当链接器遇到多个模块定义了同名的全局符号时，它会使用以下规则来决定使用哪个定义。这个机制是 C/C++ 中一个常见且隐蔽的 bug 来源。

- **强符号 (Strong)**: 函数和已初始化的全局变量。
- **弱符号 (Weak)**: 未初始化的全局变量。

**链接器规则**：

1. **不允许有多个同名的强符号**。这会直接导致链接错误。
2. 若存在一个强符号和多个同名弱符号，链接器会**选择强符号的定义**。
3. 若存在多个同名弱符号，链接器会**任意选择其中一个**。

> **编程陷阱**：规则 2 和 3 意味着链接器会默默地处理多重定义的全局变量，而不会报错。这可能导致一个模块意外地修改了另一个模块的变量，造成难以调试的错误。**最佳实践是：尽量避免使用全局变量；如果必须使用，请进行初始化，使其成为强符号**。

### 6.3. 实践：静态库与动态库

- **静态库 (Static Libraries)**
    - 静态库 (`.a` 文件) 是将一组相关的 `.o` 文件打包成一个单一文件。在链接时，链接器只从中**选择并复制**程序实际需要的模块到最终的可执行文件中。
    - **命令行顺序的重要性**：链接器按顺序扫描命令行中的文件。它维护一个未解析符号的列表。因此，**库文件必须放在命令行的末尾**。例如 `gcc main.o libmylib.a` 是正确的，而 `gcc libmylib.a main.o` 可能会因为在处理 `main.o` 之前找不到符号而失败。

- **动态库 (Shared Libraries)**
    - 为了解决静态库中代码重复和更新困难的问题，现代系统广泛使用动态库 (`.so` 文件)。
    - **动态链接**：程序在链接时，不会复制库代码，而只记录一个对库的引用。在程序**加载时或运行时**，**动态链接器** (`ld-linux.so`) 会将库加载到内存，并完成最终的重定位。
    - **核心优势**：极大地节省了磁盘空间和内存（多个进程可以共享同一份库的物理内存副本），并且更新库时无需重新编译和链接应用程序。

### 6.4. 高级技术：位置无关代码 (PIC)

为了让单个共享库副本能被加载到任意内存地址并被多进程共享，库代码必须编译为**位置无关代码 (Position-Independent Code - PIC)**。

- **实现原理**：编译器避免在代码中生成任何绝对地址。
    - **全局数据访问**：通过一个称为**全局偏移量表 (GOT)** 的数据结构间接访问。
    - **函数调用**：通过**过程链接表 (PLT)** 和 GOT 协同实现**延迟绑定 (lazy binding)**，即函数地址只在第一次被调用时才被解析，这可以加速程序的启动。

---

## 7. 第 7 章：异常控制流 (ECF) (深度解析版)

**异常控制流 (ECF)** 是操作系统用来实现其核心功能的基本机制。它指的是系统中突然的控制转移，用于响应处理器状态的变化。

### 7.1. 异常 (Exceptions)

异常是硬件和操作系统内核之间的接口，用于处理各种事件。

- **异常表 (Exception Table)**：CPU 启动时，操作系统会分配并初始化一个异常表。当异常发生时，CPU 会根据异常号，通过此表跳转到对应的内核**异常处理程序**。
- **异常的四种类型**：
    1. **中断 (Interrupt)**：**异步**的，由外部 I/O 设备事件触发。处理后返回到**下一条**指令。
    2. **陷阱 (Trap)**：**同步且有意**的，是执行指令的结果，主要用于实现**系统调用**。处理后返回到**下一条**指令。
    3. **故障 (Fault)**：**同步且可能被恢复**的错误，如**缺页故障**。处理后可能会**重新执行**导致故障的指令。
    4. **终止 (Abort)**：**同步且不可恢复**的致命硬件错误，直接终止程序。

### 7.2. 进程与上下文切换

- **进程 (Process)**：一个正在执行的程序的实例。操作系统通过给每个进程提供两种假象来实现它：
    1. **独立的逻辑控制流**：进程感觉自己独占 CPU。
    2. **私有的地址空间**：进程感觉自己独占内存（由虚拟内存实现）。
- **上下文切换 (Context Switching)**：是实现多任务的核心机制。内核**调度器 (scheduler)** 负责在进程间切换，它保存当前进程的完整状态（**上下文**），恢复下一个进程的上下文，并将控制权交给它。

### 7.3. 进程控制

- `fork()`：调用一次，返回两次。子进程获得父进程地址空间的**独立副本**（通常使用写时复制 `Copy-on-Write` 进行优化）。
- `execve()`：加载并运行一个新程序。它会**覆盖**当前进程的代码、数据和栈，但**PID 不变**。成功时**永不返回**。
- `wait()` / `waitpid()`：用于回收子进程。
    - **僵尸进程 (Zombie)**：一个已终止但其父进程尚未回收它的进程。它不执行任何代码，但仍在内核的进程表中占据一个条目。
    - **回收 (Reaping)**：父进程调用 `wait` 或 `waitpid` 来获取子进程的退出状态，并让内核彻底删除该僵尸进程。**回收子进程是父进程的责任**。
    - **孤儿进程 (Orphan)**：如果父进程先于子进程终止，这些孤儿进程会被 `init` 进程（PID 1）接管，并由 `init` 进程自动回收。

### 7.4. 信号 (Signals)

信号是一种更高层的软件 ECF，它允许进程和内核通知其他进程发生了某个事件。

- **基本概念**：信号是一种**消息**，它只有一个 ID 和一个事实：它被发送了。信号不排队，对于同一种信号，多个未处理的信号通常会被合并成一个。
- **处理信号**：进程可以**忽略**、**终止**或通过安装**信号处理程序 (signal handler)** 来**捕获**信号。
- **信号处理的挑战**：
    - **并发性**：信号处理程序是一个独立的控制流，它与主程序并发执行，访问共享的全局变量时可能会产生**竞争条件**。
    - **异步信号安全**：这是编写信号处理程序时**最重要的规则**。处理程序中**只能调用异步信号安全的函数**。像 `printf`, `malloc`, `free` 这类函数都不是安全的，因为它们不可重入。
    - **被中断的系统调用**：慢速的系统调用（如 `read`）可能会被信号中断。在这种情况下，系统调用会提前返回并设置 `errno` 为 `EINTR`。健壮的程序必须检查这种情况并手动重启系统调用。

---

## 8. 第 8 章：虚拟内存 (Virtual Memory) (深度解析版)

虚拟内存 (VM) 是对主存的一个抽象，是现代操作系统必不可少的一部分。它为每个进程提供了一个私有的、一致的地址空间，从而极大地简化了内存管理和程序安全。

### 8.1. 核心思想与动机

虚拟内存的核心思想是，为每个进程提供一个独立的、连续的**虚拟地址空间 (Virtual Address Space)**。这个空间的大小由系统的字长决定（例如 64 位系统理论上有 $2^{64}$ 的地址空间）。硬件（MMU）和操作系统内核协同工作，将虚拟地址翻译成真实的**物理地址**。

VM 的三大动机：

1. **作为缓存的工具**：将物理内存 (DRAM) 作为存储在磁盘上的数据的高速缓存。这使得系统可以运行大于物理内存的程序。
2. **作为内存管理的工具**：
    - **简化内存分配**：每个进程都有一个格式统一的虚拟地址空间，内核和用户程序的内存分配（如 `malloc`）变得非常简单，无需关心物理内存的碎片化问题。
    - **简化链接与加载**：链接器可以为所有进程生成地址布局一致的可执行文件，因为每个进程都有自己独立的虚拟地址空间。
3. **作为内存保护的工具**：
    - 通过在页表条目中设置权限位，VM 可以严格控制对内存的访问。一个进程无法访问另一个进程的私有内存，也无法修改内核或只读的代码段，从而实现了强大的内存保护。

### 8.2. 地址翻译 (Address Translation)

地址翻译是将一个虚拟地址转换成物理地址的过程。

- **页表 (Page Table)**：是存放在物理内存中的一个核心数据结构，由操作系统为每个进程维护。它本质上是一个数组，其条目称为**页表条目 (Page Table Entry, PTE)**。
- **PTE 的结构**：每个 PTE 将一个**虚拟页 (Virtual Page, VP)** 映射到一个**物理页 (Physical Page, PP)**。它主要包含：
    - 一个**有效位 (Valid Bit)**：指示该虚拟页是否被缓存在物理内存中。
    - 一个**地址字段**：如果有效位为 1，则该字段存储物理页的基地址；否则，它可能指向该页在磁盘上的位置。
    - **权限位**：如 `READ`, `WRITE`, `EXECUTE`, `USER/SUPERVISOR` 等，用于内存保护。

- **缺页 (Page Fault)**：
    当 CPU 访问一个虚拟地址，而 MMU 发现其对应的 PTE 中的有效位为 0 时，就会触发一个**缺页故障**。这是一个同步的、可恢复的异常。

- **缺页处理流程**：
    1. MMU 触发缺页异常，将控制权交给内核的缺页处理程序。
    2. 处理程序选择物理内存中的一个**牺牲页 (victim page)**。如果该页被修改过（dirty），则将其内容写回磁盘。
    3. 处理程序将所需的页面从磁盘加载到牺牲页原来的位置。
    4. 更新页表，将新加载页的 PTE 设置为有效，并指向正确的物理地址。
    5. 处理程序返回，**重新执行**导致缺页的那条指令。此时，由于页面已在内存中，地址翻译可以成功。

    > 这个过程被称为**按需页面调度 (demand paging)**，即只在需要时才将页面调入内存。

### 8.3. 加速翻译：TLB (Translation Lookaside Buffer)

由于页表本身存储在内存中，每次地址翻译都可能需要一次额外的内存访问来读取 PTE，这会极大地拖慢速度。

- **TLB**：为了解决这个问题，MMU 内部集成了一个小的、高速的、关于 PTE 的缓存，称为 **TLB**。
- **TLB 命中**：当进行地址翻译时，MMU 首先检查 TLB。如果所需的 PTE 恰好在 TLB 中，MMU 就可以直接获取物理地址，无需访问主存。这非常快。
- **TLB 未命中**：如果 TLB 中没有所需的 PTE，MMU 才需要从主存中的页表获取 PTE，并将其加载到 TLB 中，以备后续使用。
- **局部性**：得益于程序的局部性原理，TLB 的命中率非常高，使得虚拟内存系统在实践中非常高效。

### 8.4. 多级页表 (Multi-Level Page Tables)

对于一个 64 位的地址空间，如果使用单级页表，那么页表本身的大小将会是天文数字 ($2^{64-12} \times 8$ Bytes，假设页大小为 4KB)，完全不切实际。

- **解决方案**：使用一个**多级页表的层次结构**。例如，一个四级页表将虚拟地址分为多个部分，第一部分用作一级页表的索引，其条目指向一个二级页表，以此类推。
- **优点**：这种结构极大地节省了空间。如果一级页表的一个条目是空的，那么其对应的整个二级页表就不需要存在。只有当虚拟地址空间中某个区域被使用时，才会为其分配相应的页表。

---

## 9. 第 9 章：存储器层次结构与缓存 (Memory Hierarchy & Caches)

现代计算机系统通过将存储设备组织成一个层次结构，成功地弥合了 CPU 与主存之间巨大的速度差距。

### 9.1. 存储技术与 CPU-内存差距

- **存储技术**：从快到慢、从贵到便宜依次为：寄存器、SRAM（用于 CPU 缓存）、DRAM（用于主存）、SSD、旋转磁盘。
- **CPU-内存差距 (The CPU-Memory Gap)**：CPU 的性能增长速度远超 DRAM，导致 CPU 常常需要花费数百个时钟周期来等待内存数据，这形成了性能瓶颈。

### 9.2. 局部性原理 (Principle of Locality)

存储器层次结构之所以有效，完全依赖于程序的**局部性原理**。

- **时间局部性 (Temporal Locality)**：如果一个数据项被引用，那么在不久的将来它很可能再次被引用。
- **空间局部性 (Spatial Locality)**：如果一个数据项被引用，那么物理地址上邻近的数据项也很可能在不久的将来被引用。

### 9.3. 缓存的核心概念

- **组织结构**：一个缓存的结构可以由元组 `(S, E, B)` 描述：
    - `S = 2^s`: 缓存中的**组 (Set)** 的数量。
    - `E`: **相联度 (Associativity)**，即每组中包含的**行 (Line)** 的数量。
    - `B = 2^b`: **块大小 (Block Size)**，即每个缓存行存储的数据字节数。
    - 缓存总容量为 $C = S \times E \times B$。

- **地址划分**：一个 $m$ 位的地址被划分为三部分，用于在缓存中查找数据：
    - **标记 (Tag)**: $t$ 位，用于唯一标识一个内存块。
    - **组索引 (Set Index)**: $s$ 位，用于决定内存块应该存放在哪个组。
    - **块偏移 (Block Offset)**: $b$ 位，用于在块中定位所需的字节。
    - 关系为 $m = t + s + b$。

- **缓存类型**：
    - **直接映射缓存 (Direct-Mapped)**: $E=1$。每个内存块只能映射到唯一一个缓存组。优点是实现简单，缺点是容易发生**冲突未命中 (Conflict Miss)**。
    - **组相联缓存 (Set Associative)**: $1 < E < C/B$。一个内存块可以映射到特定组中的**任意一行**。这是性能和硬件成本之间的最佳折中方案。
    - **全相联缓存 (Fully Associative)**: $E = C/B$ (只有一个组)。一个内存块可以被放置在缓存的任意一行。命中率最高，但硬件实现非常昂贵和复杂。

### 9.4. 编写缓存友好的代码

编写能够高效利用缓存的代码是性能优化的关键。

- **核心思想**：最大化程序的**时间局部性**和**空间局部性**。
- **主要策略**：
    1. **聚焦内层循环**：程序的大部分时间都消耗在内层循环中。
    2. **最大化空间局部性**：在内层循环中，尽量以**步长为 1** 的模式来访问数据。例如，在 C 语言中，按行遍历二维数组比按列遍历要快得多。
    3. **最大化时间局部性**：对于一个数据，一旦它被加载到缓存，就应该尽可能多地使用它。
- **分块 (Blocking)**：是一种重要的缓存优化技术。它将数据划分为大小与缓存相匹配的**块**，并通过围绕这些块进行计算，来最大化对加载到缓存中的数据块的重复利用，从而显著提高时间局部性。

---
