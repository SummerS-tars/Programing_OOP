# ICS

## 第 6 章：链接 (Linking)

链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。这是编译过程的最后阶段，也是一个至关重要的环节。

### 6.1 链接器是做什么的？

链接器（Linker）主要执行两个任务：

1. **符号解析 (Symbol Resolution)**：目标文件定义和引用**符号**，每个符号对应一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号引用与一个确定的符号定义关联起来。
2. **重定位 (Relocation)**：编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个最终的内存地址关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存地址，从而**重定位**这些节。

### 6.2 为什么需要链接器？

- **模块化 (Modularity)**：允许我们将一个大型程序分割成多个更小、更易于管理的源文件。同时，我们可以构建公共函数的库（如 `printf`），并与无数程序共享。
- **效率 (Efficiency)**：支持分离编译。当修改程序中的一个小文件时，我们只需重新编译这个文件，然后重新链接，而无需重新编译所有其他文件，大大节省了时间。

### 6.3 目标文件类型

- **可重定位目标文件 (`.o` 文件)**：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并，创建一个可执行目标文件。
- **可执行目标文件**：包含可以直接加载到内存中执行的二进制代码和数据。
- **共享目标文件 (`.so` 文件)**：一种特殊类型的可重定位目标文件，可以在加载时或运行时被动态地加载到内存并链接。在 Windows 中，它们被称为 DLLs（动态链接库）。

### 6.4 符号和强弱符号规则

链接器在解析符号时，使用以下规则来处理多个模块中定义的同名全局符号：

- **强符号**：已初始化的全局变量和函数。
- **弱符号**：未初始化的全局变量。
- **规则 1**：不允许有多个同名的强符号。
- **规则 2**：如果有一个强符号和多个同名弱符号，则对该符号的引用解析为强符号的定义。
- **规则 3**：如果有多个同名弱符号，则从中任意选择一个进行解析。

> **注意**：这些规则，特别是规则 2 和 3，可能导致难以察觉的运行时错误，因为它们会默默地覆盖变量。因此，**应尽量避免使用全局变量**，如果必须使用，请进行初始化。

### 6.5 静态库与动态库

- **静态库 (`.a` 文件)**
    - 将所有相关的目标模块打包成一个单独的存档文件。在链接时，链接器只从库中复制程序实际引用的目标模块到最终的可执行文件中。
    - **缺点**：每个可执行文件都包含一份库代码的副本，浪费磁盘空间和内存。库更新后，需要重新链接所有依赖它的程序。

- **共享库/动态库 (`.so` 文件)**
    - 为了解决静态库的缺点而出现。共享库在运行时可以被多个进程共享。
    - **动态链接**：在程序加载时或运行时，动态链接器 (`ld-linux.so`) 会将共享库的代码和数据加载到内存，并完成符号解析和重定位。程序中只保存了对库的引用，而不是库的完整副本。
    - **优点**：节省了大量的磁盘空间和内存，并且更新库时无需重新链接程序。

### 6.6 位置无关代码 (PIC)

为了让共享库能被加载到内存的任意位置，并且能被多进程共享，它必须被编译为**位置无关代码 (PIC)**。编译器通过 **GOT (全局偏移量表)** 和 **PLT (过程链接表)** 协同工作来实现 PIC。

- **GOT (Global Offset Table)**：每个模块都有一个 GOT，它存储了该模块引用的全局变量和函数的最终地址。
- **PLT (Procedure Linkage Table)**：每个函数调用都通过 PLT 进行。PLT 利用 **延迟绑定 (lazy binding)** 技术，只有在函数第一次被调用时，才会通过动态链接器解析其真实地址并填入 GOT 中，后续调用则直接通过 GOT 跳转，提高了程序启动性能。

---

## 第 7 章：异常控制流 (Exceptional Control Flow - ECF)

系统必须能够响应各种“异常”情况，例如硬件故障、除零错误或用户按下 `Ctrl-C`。**异常控制流 (ECF)** 是操作系统用来处理这些情况的基本机制。

### 7.1 什么是 ECF？

ECF 是指在正常的程序执行流程中发生的突变，它将控制权转移给操作系统内核。它是操作系统实现 I/O、进程和虚拟内存等核心功能的基础。

### 7.2 异常的分类

异常可以分为四类：

1. **中断 (Interrupt)**：**异步**发生，由外部 I/O 设备发出信号引起。处理器处理完中断后，会返回到被中断指令的**下一条**指令继续执行。
2. **陷阱 (Trap)**：**有意**的、同步的异常，是执行某条指令的结果，最重要的用途是实现**系统调用**。陷阱处理完后，同样返回到下一条指令。
3. **故障 (Fault)**：由错误情况引起，可能被修正。例如，**缺页故障 (Page Fault)**。如果能被修正，处理器将**重新执行**导致故障的指令；否则，内核会终止程序。
4. **终止 (Abort)**：不可恢复的致命错误，通常是硬件错误。内核会直接终止当前程序。

### 7.3 进程与并发

- **进程 (Process)**：是一个正在执行的程序的实例。内核为每个进程维持一个**上下文 (context)**，即进程运行所需的所有状态信息（如 PC、寄存器、虚拟内存等）。
- **上下文切换 (Context Switching)**：内核通过上下文切换机制，在单个 CPU 上实现多个进程的**并发 (concurrent)** 执行。它保存当前进程的上下文，恢复新进程的上下文，然后将控制权交给新进程，从而造成多个程序同时运行的假象。

### 7.4 进程控制

- **创建进程 (`fork`)**：父进程通过调用 `fork` 创建一个新的子进程。`fork` 函数很有趣，它被**调用一次，返回两次**：在父进程中返回子进程的 PID，在子进程中返回 0。子进程获得父进程地址空间的一个独立副本。
- **回收子进程 (`wait` 和 `waitpid`)**：
    - 当一个进程终止后，它会变成一个“**僵尸 (zombie)**”进程，直到被其父进程“**回收 (reap)**”。
    - 父进程通过调用 `wait` 或 `waitpid` 函数来等待其子进程终止，并获取子进程的退出状态。
    - 如果父进程没有回收子进程就终止了，那么这个“**孤儿 (orphan)**”进程将被 `init` 进程（PID 为 1）接管并回收。
- **加载程序 (`execve`)**：`execve` 函数在当前进程的上下文中加载并运行一个新程序。它会覆盖当前的地址空间，但 PID 保持不变。成功调用后，`execve` **永不返回**。shell 就是通过 `fork` 和 `execve` 来执行用户命令的。

### 7.5 信号 (Signals)

信号是一种更高层的软件形式的异常，它允许进程和内核中断其他进程。

- 一个信号就是一条小消息，它通知目标进程系统中发生了某种类型的事件（如用户按下 `Ctrl-C` 会发送 `SIGINT` 信号）。
- 进程可以**忽略**、**终止**或通过安装**信号处理程序 (signal handler)** 来**捕获**信号。
- **待处理 (Pending)** 和 **阻塞 (Blocked)**：内核为每个进程维护一个待处理信号集合和一个阻塞信号掩码。信号在被接收前处于待处理状态。进程可以阻塞某种信号，被阻塞的信号在其被解除阻塞前不会被接收。
- **信号处理的挑战**：编写信号处理程序非常棘手，因为它与主程序并发执行，且可能被其他信号中断。为避免**竞争条件 (race condition)**，我们必须：
    1. 在处理程序中只调用**异步信号安全 (async-signal-safe)** 的函数。
    2. 在访问全局数据结构时，小心地阻塞和解除阻塞信号。
    3. 保存和恢复 `errno`。

---
