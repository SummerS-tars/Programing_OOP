## 第 4 章：程序的机器级表示：结构化与聚合数据 (深度解析版)

本章我们将 C 语言中的数据结构与其底层的汇编实现联系起来，重点关注内存布局、地址计算和数据对齐。

### 4.1 数组 (Arrays)

- **基本原则与指针运算**：
    - C 语言中的数组被定义为一个**连续的内存块**，其总大小为 `$L \times \text{sizeof}(T)$`，其中 `$L$` 是数组长度，$T$ 是元素类型。
    - 数组标识符（如 `a`）本身可以被看作是指向数组第一个元素 `a[0]` 的指针。
    - 因此，对数组成员的访问 `a[i]` 在底层被编译器翻译为指针运算：计算地址 $A + i \cdot \text{sizeof}(T)$，然后访问该地址的内存。

- **多维数组 (Nested Arrays)**：
    - **行主序 (Row-Major Order)**：这是 C 语言中一个至关重要的存储规则。对于一个声明为 `T A[R][C]` 的二维数组，它在内存中是按行连续存放的。即先存放第 0 行的所有 `C` 个元素，然后是第 1 行，以此类推。
    - **地址计算**：基于行主序，访问元素 `A[i][j]` 的地址计算公式为：$\&A[i][j] = A + (i \cdot C + j) \cdot \text{sizeof}(T)$。理解这个公式有助于分析代码的**空间局部性**。按行遍历（改变 `j`）的步长为 1，缓存友好；而按列遍历（改变 `i`）的步长为 `C`，可能会导致严重的缓存性能问题。

- **多级数组 (Multi-level Arrays) vs. 多维数组**：
    - **本质区别**：多维数组是一个大的、连续的内存块。而多级数组（例如通过 `int **a` 创建）是一个**指针数组**，每个指针指向一个独立的、可能不连续的内存块。
    - **访问开销**：访问多维数组元素 `A[i][j]` 只需要一次内存读取（在地址计算之后）。而访问多级数组元素 `A[i][j]` **至少需要两次内存读取**：第一次是读取指针 `A[i]` 的值，第二次才是根据这个指针去访问目标数据。因此，在性能上，多维数组通常更优。

### 4.2 结构体 (Structures)

结构体将不同类型的数据聚合到一个对象中。其在内存中的布局遵循严格的**对齐 (Alignment)** 规则。

- **数据对齐的核心原则**：
    现代处理器为了提高访存效率，要求任何大小为 `$K$` 字节的原始数据类型的地址必须是 $K$ 的倍数。例如，一个 `int` (4字节) 变量的地址应该是 4 的倍数，一个 `double` (8字节) 变量的地址应该是 8 的倍数。

- **结构体的对齐规则**：
    1. **字段对齐**：结构体中的每个字段的存放位置，其相对于结构体起始地址的偏移量，必须是该字段自身对齐要求（通常是其大小）的整数倍。为了满足这个要求，编译器可能会在字段之间插入不使用的空间，即**内部填充 (internal padding)**。
    2. **整体对齐**：一个结构体的对齐要求等于其内部**最大字段**的对齐要求。例如，一个结构体只要包含 `double` 成员，那么该结构体整体的起始地址就必须是 8 的倍数。
    3. **大小对齐**：结构体的总大小必须是其**整体对齐要求**（由规则 2 决定）的整数倍。如果当前所有字段大小之和不满足，编译器会在结构体的末尾插入**尾部填充 (tail padding)**。这条规则是为了确保在创建结构体数组时，数组中的每一个元素都能满足其对齐要求。

- **优化策略**：在定义结构体时，将**占用空间大的字段放在前面**，通常可以减少填充所带来的空间浪费。

### 4.3 联合体 (Unions)

- **内存共享**：联合体 (Union) 的所有成员共享同一块内存空间，其大小由其**最大的成员**的大小决定。
- **用途**：联合体的一个主要用途是，允许你用不同的数据类型来解释同一段内存，这在需要直接访问数据的位模式时非常有用，但也是一种潜在的不安全操作。

---
