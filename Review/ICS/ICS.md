# ICS Conclusion Ver1

---

- [1. 第 1 章：计算机系统漫游](#1-第-1-章计算机系统漫游)
    - [1.1. 信息就是“位+上下文”](#11-信息就是位上下文)
    - [1.2. 程序的翻译过程](#12-程序的翻译过程)
    - [1.3. 系统的硬件组成](#13-系统的硬件组成)
    - [1.4. “hello” 程序的执行之旅](#14-hello-程序的执行之旅)
    - [1.5. 存储器层次结构](#15-存储器层次结构)
    - [1.6. 操作系统的角色](#16-操作系统的角色)
    - [1.7. 系统知识的重要性 (The “Great Realities”)](#17-系统知识的重要性-the-great-realities)
- [2. 第 2 章：信息的表示和处理](#2-第-2-章信息的表示和处理)
    - [2.1. 信息的二进制表示](#21-信息的二进制表示)
    - [2.2. 位运算与移位运算](#22-位运算与移位运算)
    - [2.3. 整数的表示](#23-整数的表示)
        - [2.3.1. C 语言中的整数转换与陷阱](#231-c-语言中的整数转换与陷阱)
    - [2.4. 整数的扩展与截断](#24-整数的扩展与截断)
    - [2.5. 整数运算](#25-整数运算)
    - [2.6. 浮点数表示 (IEEE 754)](#26-浮点数表示-ieee-754)
    - [2.7. 浮点数舍入与运算](#27-浮点数舍入与运算)
- [3. 第 3 章：程序的机器级表示](#3-第-3-章程序的机器级表示)
    - [3.1. 基础知识与数据格式](#31-基础知识与数据格式)
    - [3.2. 访问信息](#32-访问信息)
    - [3.3. 算术与逻辑操作](#33-算术与逻辑操作)
    - [3.4. 控制 (Control Flow)](#34-控制-control-flow)
    - [3.5. 过程 (Procedures)](#35-过程-procedures)
- [4. 第 4 章：程序的机器级表示：结构化数据](#4-第-4-章程序的机器级表示结构化数据)
    - [4.1. 数组 (Arrays)](#41-数组-arrays)
    - [4.2. 结构体 (Structures)](#42-结构体-structures)
    - [4.3. 联合体 (Unions)](#43-联合体-unions)
- [5. 第 5 章：程序的机器级表示：高级主题与安全](#5-第-5-章程序的机器级表示高级主题与安全)
    - [5.1. 缓冲区溢出 (Buffer Overflow)](#51-缓冲区溢出-buffer-overflow)
    - [5.2. 对抗缓冲区溢出攻击的机制](#52-对抗缓冲区溢出攻击的机制)
    - [5.3. 返回导向编程 (Return-Oriented Programming - ROP)](#53-返回导向编程-return-oriented-programming---rop)
- [6. 第 6 章：链接 (Linking)](#6-第-6-章链接-linking)
    - [6.1. 链接器是做什么的？](#61-链接器是做什么的)
    - [6.2. 为什么需要链接器？](#62-为什么需要链接器)
    - [6.3. 目标文件类型](#63-目标文件类型)
    - [6.4. 符号和强弱符号规则](#64-符号和强弱符号规则)
    - [6.5. 静态库与动态库](#65-静态库与动态库)
    - [6.6. 位置无关代码 (PIC)](#66-位置无关代码-pic)
- [7. 第 7 章：异常控制流 (Exceptional Control Flow - ECF)](#7-第-7-章异常控制流-exceptional-control-flow---ecf)
    - [7.1. 什么是 ECF？](#71-什么是-ecf)
    - [7.2. 异常的分类](#72-异常的分类)
    - [7.3. 进程与并发](#73-进程与并发)
    - [7.4. 进程控制](#74-进程控制)
    - [7.5. 信号 (Signals)](#75-信号-signals)
- [8. 第 8 章：虚拟内存 (Virtual Memory)](#8-第-8-章虚拟内存-virtual-memory)
    - [8.1. 什么是虚拟内存？](#81-什么是虚拟内存)
    - [8.2. 虚拟内存作为缓存的工具](#82-虚拟内存作为缓存的工具)
    - [8.3. 虚拟内存作为内存管理的工具](#83-虚拟内存作为内存管理的工具)
    - [8.4. 虚拟内存作为内存保护的工具](#84-虚拟内存作为内存保护的工具)
    - [8.5. 地址翻译与 TLB](#85-地址翻译与-tlb)
- [9. 第 9 章：存储器层次结构](#9-第-9-章存储器层次结构)
    - [9.1. 存储技术与趋势](#91-存储技术与趋势)
    - [9.2. 局部性原理 (Principle of Locality)](#92-局部性原理-principle-of-locality)
    - [9.3. 缓存基础 (Cache)](#93-缓存基础-cache)
    - [9.4. 编写缓存友好的代码](#94-编写缓存友好的代码)

---

## 1. 第 1 章：计算机系统漫游

这一章将带领我们对计算机系统进行一次整体的漫游。我们将通过一个简单的 “hello, world” 程序，了解它在系统中的生命周期——从源代码到可执行文件，再到最终在屏幕上显示结果的全过程，从而对系统中的硬件、操作系统和各个组件如何协同工作有一个宏观的认识。

### 1.1. 信息就是“位+上下文”

计算机系统中所有的信息，无论是磁盘文件、内存中的程序、用户数据还是网络上传输的数据，本质上都是由一串比特（bits）来表示的。我们赋予这些比特序列不同的**上下文（context）**，才能解读它们的真实含义。

- **示例**：一个简单的 `hello.c` 程序。
    - 对于程序员来说，`hello.c` 是一个由 ASCII 字符组成的文本文件。
    - 然而，在系统内部，这个文件被表示为一串 0 和 1 的序列。
    - 当我们编译这个程序后，得到的 `hello` 可执行文件是另一串比特序列，但它的上下文已经变为**机器语言指令**，可以被处理器直接理解和执行。

```c
// hello.c 源代码
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

### 1.2. 程序的翻译过程

一个C语言程序需要通过**编译系统**的四个阶段，才能从人类可读的源代码转变为机器可执行的代码。

1. **预处理 (Preprocessing)**：预处理器 (`cpp`) 根据以 `#` 开头的命令（如 `#include <stdio.h>`）修改原始C程序，生成一个 `.i` 文件。
2. **编译 (Compilation)**：编译器 (`cc1`) 将文本文件 `hello.i` 翻译成汇编语言程序 `hello.s`。汇编语言是机器语言的文本表示。
3. **汇编 (Assembly)**：汇编器 (`as`) 将 `hello.s` 翻译成机器语言指令，并将这些指令打包成一种称为**可重定位目标程序 (relocatable object program)** 的格式，保存在 `.o` 文件中。
4. **链接 (Linking)**：链接器 (`ld`) 负责将程序中引用的库函数（如 `printf`）的代码合并到我们的 `.o` 文件中，最终生成一个完整的、可以加载到内存中执行的**可执行目标文件 (executable object file)**。

### 1.3. 系统的硬件组成

为了理解程序是如何运行的，我们需要了解一个典型系统的硬件构成。

- **总线 (Buses)**：贯穿整个系统的电子管道，负责在各个组件之间传递信息字节。
- **I/O 设备 (I/O Devices)**：是系统与外部世界的联系通道，如键盘、鼠标、显示器和磁盘。磁盘是用来长期存储可执行程序和数据的。
- **主存 (Main Memory)**：一个临时的存储设备，用于在处理器执行程序时存放程序和其处理的数据。从物理上看，主存是由一组**动态随机存取存储器 (DRAM)** 芯片组成的。
- **处理器 (CPU)**：中央处理单元，是解释和执行存储在主存中指令的引擎。
    - **程序计数器 (PC)**：CPU 核心的一个寄存器，它指向主存中下一条要执行的指令的地址。
    - **寄存器堆 (Register File)**：一个由少量寄存器组成的存储设备。
    - **算术/逻辑单元 (ALU)**：负责执行算术和逻辑运算。

### 1.4. “hello” 程序的执行之旅

当我们让系统执行 `hello` 程序时，发生了以下一系列事件：

1. **输入命令**：我们在键盘上输入字符串 `./hello`，shell 程序将字符逐一读入寄存器，再存放到主存中。
2. **加载程序**：当我们在键盘上敲下回车键后，shell 程序知道我们结束了命令输入。它会执行一系列指令来加载可执行的 `hello` 文件。这些指令将 `hello` 目标文件中的代码和数据从磁盘复制到主存。
3. **执行与输出**：一旦 `hello` 程序的代码和数据被加载到主存，处理器就开始执行 `main` 程序中的机器语言指令。这些指令将 "hello, world\n" 字符串中的字节从主存复制到寄存器堆，再从寄存器堆复制到显示设备，最终我们就在屏幕上看到了输出。

### 1.5. 存储器层次结构

系统中的存储设备被组织成一个层次结构，从上到下，设备的访问速度越来越慢，容量越来越大，每字节的造价也越来越便宜。

- **L0: 寄存器 (Registers)**
- **L1: L1 缓存 (SRAM)**
- **L2: L2 缓存 (SRAM)**
- **L3: L3 缓存 (SRAM)**
- **L4: 主存 (DRAM)**
- **L5: 本地二级存储 (本地磁盘)**
- **L6: 远程二级存储 (分布式文件系统, Web服务器)**

**缓存 (Caching)** 是这个层次结构的核心思想。上一层的存储器作为其下一层存储器的高速缓存。通过这种方式，系统可以获得巨大的存储容量，同时又能以极快的速度访问数据，仿佛拥有一个又大又快的存储器。

### 1.6. 操作系统的角色

**操作系统 (Operating System)** 是应用程序和硬件之间的中间层软件，它有两个主要功能：(1) 防止硬件被失控的应用程序滥用；(2) 向应用程序提供简单一致的机制来控制复杂的低级硬件设备。

为实现这两个功能，操作系统提出了几个关键的抽象概念：

- **进程 (Process)**：对处理器、主存和 I/O 设备的抽象。它是一个正在运行的程序的实例，为程序提供一种假象，仿佛它独占地使用系统资源。多个进程可以并发运行，由操作系统内核进行上下文切换。
- **虚拟内存 (Virtual Memory)**：对主存和磁盘的抽象。它为每个进程提供一个私有的、完整的地址空间，使得每个进程都感觉自己独占了主存。
- **文件 (File)**：对 I/O 设备的抽象，将所有 I/O 设备（如磁盘、键盘、网络）都视为字节序列。

### 1.7. 系统知识的重要性 (The “Great Realities”)

作为程序员，为什么需要理解计算机系统的工作原理？

1. **整数和浮点数并非真实世界的数字**：计算机中的算术运算受到表示范围和精度的限制，可能会出现溢出或舍入误差，这与数学上的整数和实数运算不同。
2. **你需要了解汇编**：虽然我们很少直接编写汇编代码，但理解汇编是理解程序底层行为、调试疑难杂症和进行性能优化的关键。
3. **内存很重要**：内存不是无限的，必须小心管理。内存引用错误（如越界访问）非常隐蔽且有害。此外，缓存和虚拟内存对程序性能有巨大影响。
4. **性能不仅仅是渐进复杂度**：算法的时间复杂度很重要，但常数因子、编译和执行方式、内存访问模式等同样会极大地影响程序性能。
5. **计算机不只是执行程序**：它们还需要与外部世界进行数据交互（I/O），并通过网络进行通信，这些都带来了并发、可靠性和兼容性等系统级挑战。

---

## 2. 第 2 章：信息的表示和处理

本章重点介绍计算机如何使用二进制位来表示数字（包括整数和浮点数），以及如何对这些表示进行算术和逻辑运算。理解这部分内容对于编写正确、高效且可移植的代码至关重要。

### 2.1. 信息的二进制表示

计算机中的所有数据最终都以二进制位（bit）的形式存储。为了方便读写，我们通常使用**十六进制（Hexadecimal）** 作为二进制的简写形式。

- **字节（Byte）**：是计算机中最小的可寻址内存单位，由 8 个位组成。
- **数据类型的大小**：在 C 语言中，不同的数据类型在不同位数的机器上可能占用不同大小的字节。例如，`long` 类型在 32 位系统上通常是 4 字节，而在 64 位系统上是 8 字节。

### 2.2. 位运算与移位运算

C 语言提供了强大的位运算符，可以直接对整数的位模式进行操作。

- **位逻辑运算**：
    - `&` (按位与): `0101 & 0110` -> `0100`
    - `|` (按位或): `0101 | 0110` -> `0111`
    - `^` (按位异或): `0101 ^ 0110` -> `0011`
    - `~` (按位取反): `~0101` -> `1010`
- **逻辑运算 vs. 位运算**：注意区分逻辑运算符 `&&`、`||`、`!` 和位运算符 `&`、`|`、`~`。逻辑运算符将任何非零值视为 `true`，只返回 `0` 或 `1`，并且具有“短路”特性，是一个常见的编程陷阱。
- **移位运算**：
    - `<<` (左移)：向左移动位，右边补 0。`x << k` 等效于 `x * 2^k`。
    - `>>` (右移)：向右移动位。分为两种：
        - **逻辑右移**：左边补 0。用于无符号数。
        - **算术右移**：左边补最高有效位（符号位）。用于有符号数。

### 2.3. 整数的表示

整数分为**无符号（Unsigned）** 和**有符号（Signed）** 两种类型。

- **无符号整数**：所有位都用来表示数值的大小。一个 $w$ 位的无符号数可以表示的范围是 $0$ 到 $2^w - 1$。
- **有符号整数**：最常用的是**补码（Two's Complement）** 表示法。
    - **最高有效位 (MSB)** 是**符号位**，0 代表非负数，1 代表负数。
    - 一个 $w$ 位的补码数可以表示的范围是 $-2^{w-1}$ 到 $2^{w-1} - 1$，这是一个不对称的范围。
    - 正数的补码就是其本身。负数的补码可以通过将其对应的正数按位取反再加 1 得到。例如，对于一个 8 位整数，-1 的补码是 `~1 + 1` -> `11111110 + 1` -> `11111111`。

#### 2.3.1. C 语言中的整数转换与陷阱

在 C 语言中，当有符号数和无符号数混合运算时，有符号数会**隐式地转换为无符号数**，这常常导致违反直觉的结果。

```c
// C 语言中的转换陷阱
// 表达式 -1 < 0U 的结果是什么？
// 结果是 false。因为 -1 (有符号) 被转换为了一个非常大的无符号数 (UMax)，
// 所以表达式变为 UMax < 0，结果为假。

int x = -1;
unsigned int y = 0;

if (x < y) {
    printf("-1 < 0U is TRUE\n"); // 这行不会被执行
} else {
    printf("-1 < 0U is FALSE\n"); // 这行会被执行
}
```

### 2.4. 整数的扩展与截断

- **扩展（Converting to a Larger Data Type）**：
    - **零扩展**：对于无符号数，在高位添加 0。
    - **符号扩展**：对于有符号数，在高位添加符号位的副本。
- **截断（Converting to a Smaller Data Type）**：
    - 直接丢弃高位比特。
    - 对于无符号数，效果等同于模 $2^k$（k 是目标类型的位数）。
    - 对于有符号数，结果可能会改变符号。

### 2.5. 整数运算

- **加法**：
    - 无符号加法和补码加法的位级表示是完全相同的。
    - **无符号加法溢出**：当结果超出了表示范围时发生，相当于结果对 $2^w$ 取模。
    - **补码加法溢出**：当两个正数相加得到负数，或两个负数相加得到正数时发生。
- **乘法**：
    - 计算机执行的乘法运算会截断结果，只保留低 $w$ 位。
    - 对于无符号乘法，这相当于计算 `(x * y) mod 2^w`。
    - 对于补码乘法，位级行为与无符号乘法一致。
- **乘以/除以 2 的幂**：
    - 可以通过移位运算高效实现。左移 $k$ 位等效于乘以 $2^k$。
    - 右移 $k$ 位等效于除以 $2^k$。对于负数的除法，需要进行**偏置 (biasing)** 来保证向零舍入的正确性。

### 2.6. 浮点数表示 (IEEE 754)

为了表示小数，计算机系统采用 **IEEE 754** 浮点标准。一个浮点数被编码为：$V = (-1)^s \times M \times 2^E$。

- **符号 (s)**：1 位，决定数的正负。
- **阶码 (E)**：由 `exp` 字段编码，是一个有符号整数。
- **尾数 (M)**：由 `frac` 字段编码，是一个二进制小数。

根据 `exp` 和 `frac` 的值，浮点数分为三种类型：

1. **规格化的 (Normalized)**
    - 条件：`exp` 既不全为 0，也不全为 1。
    - 阶码：$E = exp - Bias$，其中 $Bias = 2^{k-1} - 1$（k 是 exp 的位数）。
    - 尾数：$M = 1 + frac$。有一个隐含的、值为 1 的前导位。这是最常见的情况。

2. **非规格化的 (Denormalized)**
    - 条件：`exp` 全为 0。
    - 用于表示非常接近 0 的数和 0 本身。
    - 阶码：$E = 1 - Bias$。
    - 尾数：$M = frac$。没有隐含的前导 1。

3. **特殊值 (Special)**
    - 条件：`exp` 全为 1。
    - 如果 `frac` 全为 0，表示**无穷大 (infinity)**，正负取决于符号位 s。
    - 如果 `frac` 不为 0，表示 **“不是一个数” (NaN, Not-a-Number)** 。

### 2.7. 浮点数舍入与运算

由于表示是有限的，浮点运算的结果通常需要舍入。

- **舍入模式**：IEEE 754 定义了四种舍入模式，默认是**向偶数舍入 (Round-to-even)**。这种模式在统计上偏差最小。
- **浮点运算**：基本思想是先计算出精确值，然后根据舍入模式调整到最接近的可表示值。
- **运算性质**：浮点加法不满足结合律，因为舍入会引入误差。`(3.14 + 1e20) - 1e20` 的结果是 `0.0`，而 `3.14 + (1e20 - 1e20)` 的结果是 `3.14`。

---

## 3. 第 3 章：程序的机器级表示

本章我们将学习 x86-64 架构下的汇编语言，它是 C 语言和处理器硬件之间的桥梁。我们将探索数据的表示和移动、算术运算、控制流（如循环和分支）以及过程（函数）调用在机器层面是如何实现的。

### 3.1. 基础知识与数据格式

- **ISA (指令集架构)**：定义了处理器状态、指令格式以及每条指令对状态的影响，是软件和硬件之间的契约。我们主要关注 x86-64 架构。
- **C 到汇编**：我们可以使用 `gcc -Og -S a.c` 命令来让编译器将 C 语言代码编译成汇编代码 `a.s` 文件，从而观察程序的机器级表示。
- **数据格式**：x86-64 指令的后缀通常表示操作数的大小。例如 `movb` (字节, 1 byte), `movw` (字, 2 bytes), `movl` (双字, 4 bytes), `movq` (四字, 8 bytes)。

### 3.2. 访问信息

- **寄存器 (Registers)**：x86-64 CPU 包含 16 个 64 位的通用目的寄存器，用于存储整数和指针。
    - `%rax`: 通常用作返回值。
    - `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`: 用于传递前六个函数参数。
    - `%rsp`: 栈指针，指向栈顶。
    - 其他寄存器如 `%rbx`, `%rbp`, `%r10` - `%r15` 也有专门的用途。

- **操作数类型 (Operand Types)**：指令的操作数可以是三种类型：
    - **立即数 (Immediate)**：常量值，在汇编中以 `$` 开头，如 `$577`。
    - **寄存器 (Register)**：16 个通用寄存器之一，如 `%rax`。
    - **内存引用 (Memory)**：根据计算出的地址访问内存中的数据。

- **`mov` 指令**：是最基本的数据传送指令，用于在寄存器和内存之间移动数据。格式为 `movq source, destination`。
    - **重要限制**：`mov` 指令不能实现一次性的**内存到内存**的复制。需要两条指令来完成：先从内存加载到寄存器，再从寄存器存储到另一内存地址。

- **寻址模式 (Addressing Modes)**：x86-64 支持多种复杂的寻址模式，最常用的是 `D(Rb, Ri, S)` 形式。
    - 它表示的地址为：`Mem[Reg[Rb] + S * Reg[Ri] + D]`。
    - `D`: 常量位移 (Displacement)。
    - `Rb`: 基址寄存器 (Base)。
    - `Ri`: 变址寄存器 (Index)。
    - `S`: 比例因子 (Scale)，值必须是 1, 2, 4, 或 8。

### 3.3. 算术与逻辑操作

- **`leaq` 指令 (Load Effective Address)**：这是一个非常重要的指令，它的功能是**计算地址**并将其存入目标寄存器，但**不访问内存**。它常被编译器用来高效地执行简单的算术运算。
    - 例如，`leaq (%rdi, %rsi, 4), %rax` 可以将 `rdi + rsi * 4` 的值存入 `%rax`，实现了两次乘法和一次加法的功能。

- **算术与逻辑指令**：包括加 (`addq`)、减 (`subq`)、与 (`andq`)、或 (`orq`)、异或 (`xorq`) 等。这些指令通常有两个操作数，格式为 `op source, destination`，其效果是 `destination = destination op source`。

### 3.4. 控制 (Control Flow)

- **条件码 (Condition Codes)**：CPU 维护一组单个 bit 的条件码寄存器，用于描述最近一次算术或逻辑运算的结果的属性。
    - `CF`: 进位标志，用于无符号数溢出。
    - `ZF`: 零标志，当结果为 0 时设置。
    - `SF`: 符号标志，当结果为负时设置。
    - `OF`: 溢出标志，用于有符号数溢出。

- **`cmp` 和 `test` 指令**：这两条指令只设置条件码，不改变其他寄存器的值。
    - `cmpq src2, src1`：基于 `src1 - src2` 的结果设置条件码。
    - `testq src2, src1`：基于 `src1 & src2` 的结果设置条件码。

- **跳转指令 (Jump Instructions)**：根据条件码的状态来改变程序的执行流。
    - `jmp`：无条件跳转。
    - `je` (jump when equal), `jg` (jump when greater), `jl` (jump when less) 等：条件跳转。

- **循环的实现**：C 语言中的 `for`, `while`, `do-while` 循环都可以被翻译成使用条件测试和跳转指令实现的汇编代码。

- **Switch 语句的实现**：对于多分支的 `switch` 语句，编译器会使用一种高效的实现方式，称为**跳转表 (Jump Table)**。跳转表是一个数组，存储了每个 case 对应的代码块的地址。执行 `switch` 时，程序通过索引跳转表直接跳转到目标代码，避免了冗长的 `if-else-if` 链。

### 3.5. 过程 (Procedures)

过程（即函数）是软件中一种重要的抽象。

- **运行时栈 (The Stack)**：x86-64 使用栈来支持函数调用。栈向低地址方向增长，`%rsp` 寄存器始终指向栈顶元素。
    - `pushq src`：将 `%rsp` 减 8，然后将 `src` 的值存入新的栈顶地址。
    - `popq dest`：从栈顶读取值到 `dest`，然后将 `%rsp` 加 8。

- **调用与返回**：
    - `call label`：将返回地址（`call` 指令之后的那条指令的地址）压入栈中，然后跳转到 `label` 处。
    - `ret`：从栈中弹出返回地址，并跳转到该地址。

- **栈帧 (Stack Frame)**：每个函数在调用时都会在栈上分配一个独立的区域，称为栈帧，用于存储返回信息、局部变量和参数。

- **参数传递**：x86-64 约定，前 6 个整数或指针类型的参数通过寄存器传递，顺序为 `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`。超过 6 个的参数则通过栈来传递。

- **寄存器使用惯例**：为了防止函数调用时相互覆盖对方的数据，x86-64 建立了一套寄存器使用惯例。
    - **调用者保存 (Caller-Saved)**：寄存器 `%rax` 以及用于传递参数的 `%rdi` - `%r9`, `%r10`, `%r11` 属于调用者保存寄存器。当函数 P 调用函数 Q 时，P 必须自己负责保存这些寄存器的值，因为 Q 可以随意修改它们。
    - **被调用者保存 (Callee-Saved)**：寄存器 `%rbx`, `%rbp`, `%r12` - `%r15` 属于被调用者保存寄存器。Q 必须在返回前将这些寄存器的值恢复到调用前的状态。

- **递归 (Recursion)**：由于每个函数调用都有自己的私有栈帧，递归的实现方式与普通函数调用并无二致，遵循同样的栈纪律和寄存器保存惯例。

---

## 4. 第 4 章：程序的机器级表示：结构化数据

本章我们关注 C 语言中的聚合数据类型，理解它们在汇编层面的实现方式对于编写高效和正确的代码至关重要。

### 4.1. 数组 (Arrays)

- **分配与访问**：
    - C 语言中的数组是一块连续分配的内存区域，其大小为 `元素数量 × 元素大小`。
    - 数组名可以看作是指向数组第一个元素的指针。访问 `A[i]` 的地址是通过指针运算 `A + i * sizeof(元素类型)` 计算得到的。

- **多维数组 (Nested Arrays)**：
    - C 语言的多维数组以 **行主序 (Row-Major Order)** 存储，即内存中先连续存放第 0 行的所有元素，然后是第 1 行，以此类推。
    - 这种存储方式决定了，按行遍历二维数组具有良好的**空间局部性**，而按列遍历则较差，这会极大地影响缓存性能。

- **多级数组 (Multi-level Arrays)**：
    - 与多维数组不同，多级数组的本质是“指针的数组”。每个元素都是一个指针，指向另一块独立的内存区域。
    - 访问一个元素 `A[i][j]` 需要两次内存读取：第一次读取指针 `A[i]` 的值，第二次根据这个指针值去访问它所指向数组的第 `j` 个元素。

### 4.2. 结构体 (Structures)

- **内存布局**：
    - 结构体的所有字段都存储在一块连续的内存中，字段的顺序与声明顺序一致。
    - 编译器负责计算每个字段的偏移量 (offset) 和结构体的总大小。

- **数据对齐 (Alignment)**：
    - **原则**：为了提高内存访问效率，硬件通常要求数据存放在其地址是该数据类型大小的倍数的位置。例如，一个 8 字节的 `double` 变量，其地址应该是 8 的倍数。
    - **结构体对齐规则**：
        1. **字段对齐**：结构体中的每个字段必须放置在相对于结构体起始地址的、是其自身大小倍数的偏移量上。为此，编译器可能会在字段之间插入不使用的空间，称为**内部填充 (internal padding)**。
        2. **整体对齐**：整个结构体的对齐要求与其内部最大字段的对齐要求相同。例如，如果一个结构体中最大的字段是 `double`（8字节），那么整个结构体的起始地址必须是 8 的倍数。
        3. **大小对齐**：结构体的总大小必须是其整体对齐要求的整数倍。为此，编译器可能在结构体的末尾添加**尾部填充 (tail padding)**。

```c
// 结构体对齐示例
struct S1 {
    double v; // 8 字节
    int i; // 4 字节
    char c; // 1 字节
};
// 字段 v 在偏移量 0
// 字段 i 在偏移量 8
// 字段 c 在偏移量 12
// 结构体总大小需要是 8 的倍数，所以末尾填充 3 字节。
// sizeof(S1) 的结果是 16，而不是 8+4+1=13。

// 优化：将大的数据类型放在前面可以减少填充，节省空间
struct S2 {
    double v; // 8 字节
    char c; // 1 字节
    int i; // 4 字节
}; 
// 这种声明方式下，sizeof(S2) 仍然是 16。但如果把 v 放在最后，
// 比如 char c, int i, double v，则总大小会变成 24。
```

### 4.3. 联合体 (Unions)

- 联合体的所有成员共享同一块内存空间。
- 它的大小由其最大的成员的大小决定。
- 联合体的一个巧妙用途是，在不进行类型转换的情况下，查看一个数据类型的位级表示。例如，通过联合体我们可以直接访问一个 `float` 变量的二进制位模式，就好像它是一个 `unsigned int` 一样。

---

## 5. 第 5 章：程序的机器级表示：高级主题与安全

本章探讨一些更高级的话题，重点是现代安全领域最核心的挑战之一：缓冲区溢出。

### 5.1. 缓冲区溢出 (Buffer Overflow)

- **定义**：当程序向一个缓冲区（通常是栈上的字符数组）写入的数据超出了其边界时，就会发生缓冲区溢出。
- **栈破坏 (Stack Smashing)**：由于栈上存放着局部变量、保存的寄存器状态以及**返回地址**，缓冲区溢出可能会覆盖这些关键数据。最危险的情况是，攻击者可以精心构造输入，精确地覆盖函数的**返回地址**。
- **代码注入攻击**：
    1. 攻击者将一段恶意的机器代码（称为 *shellcode*）作为输入字符串的一部分。
    2. 通过溢出，他们用这段恶意代码的起始地址来覆盖原始的返回地址。
    3. 当函数执行 `ret` 指令时，程序不会返回到调用者，而是会跳转到攻击者注入的代码并执行它，从而获得系统的控制权。

### 5.2. 对抗缓冲区溢出攻击的机制

为了应对这类攻击，现代系统采取了多种防御措施。

1. **栈随机化 (Stack Randomization)**
    - 也称为**地址空间布局随机化 (ASLR)**，程序每次运行时，栈的起始地址都是随机的。
    - 这使得攻击者难以预测他们注入的代码的准确地址，从而让攻击变得非常困难。

2. **栈金丝雀/栈保护 (Stack Canaries)**
    - 编译器在函数的栈帧中，在任何缓冲区和返回地址之间，放置一个特殊的随机值，称为 **“金丝雀” (canary)** 。
    - 在函数返回之前，程序会检查这个金丝雀的值是否被改变。如果被改变，说明发生了缓冲区溢出，程序会立即终止，而不是执行被篡改的返回地址。

3. **非可执行内存 (Non-Executable Memory)**
    - 现代处理器允许将内存区域标记为“可读”、“可写”或“可执行”。
    - 通过将栈内存区域标记为不可执行，即使攻击者成功注入了代码，CPU 也会拒绝执行该代码，从而阻止了攻击。

### 5.3. 返回导向编程 (Return-Oriented Programming - ROP)

ROP 是一种更高级的攻击技术，旨在绕过“非可执行内存”的防御。

- **核心思想**：攻击者不注入新代码，而是在现有代码（如标准库 `libc`）中寻找一系列有用的、以 `ret` 指令结尾的短指令序列，这些序列被称为 **“小工具” (gadgets)** 。
- **攻击方式**：攻击者通过缓冲区溢出，用一连串精心挑选的 gadget 的地址来覆盖栈。当第一个 `ret` 指令执行时，它会跳转到第一个 gadget；当这个 gadget 执行完毕后的 `ret` 又会从栈上弹出下一个 gadget 的地址并跳转...如此往复，将这些小程序片段串联起来，执行复杂的恶意操作。

---

## 6. 第 6 章：链接 (Linking)

链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。这是编译过程的最后阶段，也是一个至关重要的环节。

### 6.1. 链接器是做什么的？

链接器（Linker）主要执行两个任务：

1. **符号解析 (Symbol Resolution)**：目标文件定义和引用**符号**，每个符号对应一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号引用与一个确定的符号定义关联起来。
2. **重定位 (Relocation)**：编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个最终的内存地址关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存地址，从而**重定位**这些节。

### 6.2. 为什么需要链接器？

- **模块化 (Modularity)**：允许我们将一个大型程序分割成多个更小、更易于管理的源文件。同时，我们可以构建公共函数的库（如 `printf`），并与无数程序共享。
- **效率 (Efficiency)**：支持分离编译。当修改程序中的一个小文件时，我们只需重新编译这个文件，然后重新链接，而无需重新编译所有其他文件，大大节省了时间。

### 6.3. 目标文件类型

- **可重定位目标文件 (`.o` 文件)**：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并，创建一个可执行目标文件。
- **可执行目标文件**：包含可以直接加载到内存中执行的二进制代码和数据。
- **共享目标文件 (`.so` 文件)**：一种特殊类型的可重定位目标文件，可以在加载时或运行时被动态地加载到内存并链接。在 Windows 中，它们被称为 DLLs（动态链接库）。

### 6.4. 符号和强弱符号规则

链接器在解析符号时，使用以下规则来处理多个模块中定义的同名全局符号：

- **强符号**：已初始化的全局变量和函数。
- **弱符号**：未初始化的全局变量。
- **规则 1**：不允许有多个同名的强符号。
- **规则 2**：如果有一个强符号和多个同名弱符号，则对该符号的引用解析为强符号的定义。
- **规则 3**：如果有多个同名弱符号，则从中任意选择一个进行解析。

> **注意**：这些规则，特别是规则 2 和 3，可能导致难以察觉的运行时错误，因为它们会默默地覆盖变量。因此，**应尽量避免使用全局变量**，如果必须使用，请进行初始化。

### 6.5. 静态库与动态库

- **静态库 (`.a` 文件)**
    - 将所有相关的目标模块打包成一个单独的存档文件。在链接时，链接器只从库中复制程序实际引用的目标模块到最终的可执行文件中。
    - **缺点**：每个可执行文件都包含一份库代码的副本，浪费磁盘空间和内存。库更新后，需要重新链接所有依赖它的程序。

- **共享库/动态库 (`.so` 文件)**
    - 为了解决静态库的缺点而出现。共享库在运行时可以被多个进程共享。
    - **动态链接**：在程序加载时或运行时，动态链接器 (`ld-linux.so`) 会将共享库的代码和数据加载到内存，并完成符号解析和重定位。程序中只保存了对库的引用，而不是库的完整副本。
    - **优点**：节省了大量的磁盘空间和内存，并且更新库时无需重新链接程序。

### 6.6. 位置无关代码 (PIC)

为了让共享库能被加载到内存的任意位置，并且能被多进程共享，它必须被编译为**位置无关代码 (PIC)**。编译器通过 **GOT (全局偏移量表)** 和 **PLT (过程链接表)** 协同工作来实现 PIC。

- **GOT (Global Offset Table)**：每个模块都有一个 GOT，它存储了该模块引用的全局变量和函数的最终地址。
- **PLT (Procedure Linkage Table)**：每个函数调用都通过 PLT 进行。PLT 利用 **延迟绑定 (lazy binding)** 技术，只有在函数第一次被调用时，才会通过动态链接器解析其真实地址并填入 GOT 中，后续调用则直接通过 GOT 跳转，提高了程序启动性能。

---

## 7. 第 7 章：异常控制流 (Exceptional Control Flow - ECF)

系统必须能够响应各种“异常”情况，例如硬件故障、除零错误或用户按下 `Ctrl-C`。**异常控制流 (ECF)** 是操作系统用来处理这些情况的基本机制。

### 7.1. 什么是 ECF？

ECF 是指在正常的程序执行流程中发生的突变，它将控制权转移给操作系统内核。它是操作系统实现 I/O、进程和虚拟内存等核心功能的基础。

### 7.2. 异常的分类

异常可以分为四类：

1. **中断 (Interrupt)**：**异步**发生，由外部 I/O 设备发出信号引起。处理器处理完中断后，会返回到被中断指令的**下一条**指令继续执行。
2. **陷阱 (Trap)**：**有意**的、同步的异常，是执行某条指令的结果，最重要的用途是实现**系统调用**。陷阱处理完后，同样返回到下一条指令。
3. **故障 (Fault)**：由错误情况引起，可能被修正。例如，**缺页故障 (Page Fault)**。如果能被修正，处理器将**重新执行**导致故障的指令；否则，内核会终止程序。
4. **终止 (Abort)**：不可恢复的致命错误，通常是硬件错误。内核会直接终止当前程序。

### 7.3. 进程与并发

- **进程 (Process)**：是一个正在执行的程序的实例。内核为每个进程维持一个**上下文 (context)**，即进程运行所需的所有状态信息（如 PC、寄存器、虚拟内存等）。
- **上下文切换 (Context Switching)**：内核通过上下文切换机制，在单个 CPU 上实现多个进程的**并发 (concurrent)** 执行。它保存当前进程的上下文，恢复新进程的上下文，然后将控制权交给新进程，从而造成多个程序同时运行的假象。

### 7.4. 进程控制

- **创建进程 (`fork`)**：父进程通过调用 `fork` 创建一个新的子进程。`fork` 函数很有趣，它被**调用一次，返回两次**：在父进程中返回子进程的 PID，在子进程中返回 0。子进程获得父进程地址空间的一个独立副本。
- **回收子进程 (`wait` 和 `waitpid`)**：
    - 当一个进程终止后，它会变成一个“**僵尸 (zombie)**”进程，直到被其父进程“**回收 (reap)**”。
    - 父进程通过调用 `wait` 或 `waitpid` 函数来等待其子进程终止，并获取子进程的退出状态。
    - 如果父进程没有回收子进程就终止了，那么这个“**孤儿 (orphan)**”进程将被 `init` 进程（PID 为 1）接管并回收。
- **加载程序 (`execve`)**：`execve` 函数在当前进程的上下文中加载并运行一个新程序。它会覆盖当前的地址空间，但 PID 保持不变。成功调用后，`execve` **永不返回**。shell 就是通过 `fork` 和 `execve` 来执行用户命令的。

### 7.5. 信号 (Signals)

信号是一种更高层的软件形式的异常，它允许进程和内核中断其他进程。

- 一个信号就是一条小消息，它通知目标进程系统中发生了某种类型的事件（如用户按下 `Ctrl-C` 会发送 `SIGINT` 信号）。
- 进程可以**忽略**、**终止**或通过安装**信号处理程序 (signal handler)** 来**捕获**信号。
- **待处理 (Pending)** 和 **阻塞 (Blocked)**：内核为每个进程维护一个待处理信号集合和一个阻塞信号掩码。信号在被接收前处于待处理状态。进程可以阻塞某种信号，被阻塞的信号在其被解除阻塞前不会被接收。
- **信号处理的挑战**：编写信号处理程序非常棘手，因为它与主程序并发执行，且可能被其他信号中断。为避免**竞争条件 (race condition)**，我们必须：
    1. 在处理程序中只调用**异步信号安全 (async-signal-safe)** 的函数。
    2. 在访问全局数据结构时，小心地阻塞和解除阻塞信号。
    3. 保存和恢复 `errno`。

---

## 8. 第 8 章：虚拟内存 (Virtual Memory)

虚拟内存是计算机系统最重要的概念之一。它为每个进程提供了一个大的、一致的和私有的地址空间，从而极大地简化了内存管理和程序编写。

### 8.1. 什么是虚拟内存？

虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件之间精密交互的产物。它为每个进程提供了一个假象，让进程感觉自己拥有一个私有的、从 0 开始的连续地址空间，称为**虚拟地址空间 (virtual address space)**。

实际上，这些虚拟地址会由硬件（**MMU, 内存管理单元**）和操作系统协作，翻译成**物理地址**，数据实际存储在物理主存（DRAM）中。

### 8.2. 虚拟内存作为缓存的工具

虚拟内存系统将虚拟地址空间分割成大小固定的块，称为**虚拟页 (Virtual Pages, VP)**。同样，物理内存也被分割成相同大小的**物理页 (Physical Pages, PP)**。物理内存（DRAM）在这里扮演了磁盘上数据的高速缓存角色。

- **页表 (Page Table)**：操作系统为每个进程维护一个页表，它是一个将虚拟页映射到物理页的数据结构。
- **页命中 (Page Hit)**：当 CPU 需要访问一个虚拟地址时，如果其对应的物理页恰好在主存中，MMU 能直接完成地址翻译，这就是一次页命中。
- **缺页 (Page Fault)**：如果对应的物理页不在主存中（即 DRAM 缓存未命中），就会触发一个**缺页异常**。
- **缺页处理**：
    1. 缺页异常会陷入内核。
    2. 内核中的缺页处理程序会从磁盘加载所需的页面到主存的一个物理页中。如果主存已满，会选择一个“牺牲”页将其换出。
    3. 更新页表，以反映新的映射关系。
    4. 处理程序返回，并**重新执行**导致缺页的指令。此时，由于数据已在内存中，指令可以成功执行。
    - 这种在需要时才将页面从磁盘加载到内存的策略称为**按需页面调度 (demand paging)**。

### 8.3. 虚拟内存作为内存管理的工具

- **简化内存分配**：虚拟内存为每个进程提供了一个统一的线性地址空间，使得内核和用户程序在分配内存时无需关心物理内存的碎片化问题。
- **简化链接与加载**：每个进程的地址空间布局都是一致的（例如，代码段总是从相同的虚拟地址开始），这极大地简化了链接器和加载器的设计。
- **共享代码和数据**：操作系统可以将不同进程的虚拟页映射到相同的物理页，从而实现代码和数据（如 C 标准库）的共享，节省了宝贵的内存资源。

### 8.4. 虚拟内存作为内存保护的工具

虚拟内存通过在页表条目（PTE）中添加权限位（如读、写、执行、用户/内核模式），提供了一种精确的内存保护机制。

- MMU 在每次地址翻译时都会检查这些权限位。
- 如果一条指令试图违反权限（例如，用户模式下的程序试图写入一个只读的代码段），CPU 会触发一个**通用保护故障 (general protection fault)**，内核会捕获这个故障并通常会终止该进程。

### 8.5. 地址翻译与 TLB

由于页表存储在主存中，每次地址翻译都可能需要额外的内存访问，这会降低效率。为了加速地址翻译，MMU 中包含了一个小的、关于页表条目的高速缓存，称为**翻译后备缓冲区 (Translation Lookaside Buffer, TLB)**。

- 当 MMU 进行地址翻译时，它首先检查 TLB。
- **TLB 命中**：如果所需的 PTE 在 TLB 中，MMU 可以直接获取物理地址，无需访问主存。这非常快。
- **TLB 未命中**：如果 PTE 不在 TLB 中，MMU 才需要从主存中的页表获取 PTE，并将其加载到 TLB 中，以备后续使用。

---

## 9. 第 9 章：存储器层次结构

现代计算机系统的存储器被组织成一个层次结构，它利用了程序访问的**局部性原理**，为我们提供了既大又快的存储系统。

### 9.1. 存储技术与趋势

- **SRAM**：速度快，价格昂贵，用于构建 CPU 缓存。
- **DRAM**：速度比 SRAM 慢，但更便宜，用于构建主存。
- **磁盘**：速度最慢，但容量巨大且非易失，用于长期存储。
- **CPU-内存差距**：CPU 的速度增长远快于 DRAM，导致了所谓的“**存储墙 (Memory Wall)**”。CPU 常常需要花费数百个时钟周期等待数据从主存到达。

### 9.2. 局部性原理 (Principle of Locality)

程序倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这是存储器层次结构能够工作的根本原因。

- **时间局部性 (Temporal Locality)**：如果一个数据项被引用，那么在不久的将来它很可能再次被引用。
- **空间局部性 (Spatial Locality)**：如果一个数据项被引用，那么在不久的将来它附近的数据项也很可能被引用。

### 9.3. 缓存基础 (Cache)

- **缓存**：一个更小、更快的存储设备，用作更大、更慢设备中数据子集的暂存区。
- **缓存命中 (Cache Hit)**：当程序需要的数据恰好在缓存中时。
- **缓存未命中 (Cache Miss)**：当数据不在缓存中时，需要从下一级存储中获取，这会带来显著的**未命中惩罚 (miss penalty)**。
- **缓存的组织 (S, E, B)**：
    - `B`：块大小 (Block size)。
    - `S`：组数 (Number of sets)。
    - `E`：相联度 (Associativity)，即每组中的行数。
- **缓存类型**：
    - **直接映射 (`E=1`)**：每个内存块只能映射到缓存中的一个特定行。简单但易发生冲突未命中。
    - **组相联 (`1 < E < C/B`)**：一个内存块可以映射到特定组中的任意一行。是性能和成本的良好折中。
    - **全相联 (`E = C/B`)**：一个内存块可以映射到缓存中的任意一行。最灵活但硬件实现最复杂。

### 9.4. 编写缓存友好的代码

编写能够有效利用缓存的代码是性能优化的关键。

- **核心思想**：最大化程序的空间和时间局部性。
- **基本准则**：
    1. **聚焦内层循环**：大部分计算都发生在循环中。
    2. **最大化空间局部性**：在内层循环中，尽量以**步长为 1** 的模式访问数据。
    3. **最大化时间局部性**：让被重复引用的数据项尽可能地在缓存中停留。

- **示例：矩阵乘法**
    - 一个简单的 `ijk` 循环顺序会导致对第二个矩阵的访问是按列的，步长很大，空间局部性极差。
    - 通过交换循环顺序（如改为 `kij` 或 `jik`），可以改变内存访问模式，将一个或多个数组的访问变为步长为 1，从而显著减少缓存未命中次数，将性能提升数倍。

- **分块 (Blocking)**：一种高级的优化技术，通过将数据分成小的“块”，并让计算围绕这些块进行，从而将一个数据集加载到缓存中并最大化地重复使用它，极大地提高了时间局部性。

---
