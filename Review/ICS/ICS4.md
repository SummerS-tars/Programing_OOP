# ICS

## 第 4 章：程序的机器级表示：结构化数据

本章我们关注 C 语言中的聚合数据类型，理解它们在汇编层面的实现方式对于编写高效和正确的代码至关重要。

### 4.1 数组 (Arrays)

- **分配与访问**：
    - C 语言中的数组是一块连续分配的内存区域，其大小为 `元素数量 × 元素大小`。
    - 数组名可以看作是指向数组第一个元素的指针。访问 `A[i]` 的地址是通过指针运算 `A + i * sizeof(元素类型)` 计算得到的。

- **多维数组 (Nested Arrays)**：
    - C 语言的多维数组以 **行主序 (Row-Major Order)** 存储，即内存中先连续存放第 0 行的所有元素，然后是第 1 行，以此类推。
    - 这种存储方式决定了，按行遍历二维数组具有良好的**空间局部性**，而按列遍历则较差，这会极大地影响缓存性能。

- **多级数组 (Multi-level Arrays)**：
    - 与多维数组不同，多级数组的本质是“指针的数组”。每个元素都是一个指针，指向另一块独立的内存区域。
    - 访问一个元素 `A[i][j]` 需要两次内存读取：第一次读取指针 `A[i]` 的值，第二次根据这个指针值去访问它所指向数组的第 `j` 个元素。

### 4.2 结构体 (Structures)

- **内存布局**：
    - 结构体的所有字段都存储在一块连续的内存中，字段的顺序与声明顺序一致。
    - 编译器负责计算每个字段的偏移量 (offset) 和结构体的总大小。

- **数据对齐 (Alignment)**：
    - **原则**：为了提高内存访问效率，硬件通常要求数据存放在其地址是该数据类型大小的倍数的位置。例如，一个 8 字节的 `double` 变量，其地址应该是 8 的倍数。
    - **结构体对齐规则**：
        1. **字段对齐**：结构体中的每个字段必须放置在相对于结构体起始地址的、是其自身大小倍数的偏移量上。为此，编译器可能会在字段之间插入不使用的空间，称为**内部填充 (internal padding)**。
        2. **整体对齐**：整个结构体的对齐要求与其内部最大字段的对齐要求相同。例如，如果一个结构体中最大的字段是 `double`（8字节），那么整个结构体的起始地址必须是 8 的倍数。
        3. **大小对齐**：结构体的总大小必须是其整体对齐要求的整数倍。为此，编译器可能在结构体的末尾添加**尾部填充 (tail padding)**。

```c
// 结构体对齐示例
struct S1 {
    double v; // 8 字节
    int i; // 4 字节
    char c; // 1 字节
};
// 字段 v 在偏移量 0
// 字段 i 在偏移量 8
// 字段 c 在偏移量 12
// 结构体总大小需要是 8 的倍数，所以末尾填充 3 字节。
// sizeof(S1) 的结果是 16，而不是 8+4+1=13。

// 优化：将大的数据类型放在前面可以减少填充，节省空间
struct S2 {
    double v; // 8 字节
    char c; // 1 字节
    int i; // 4 字节
}; 
// 这种声明方式下，sizeof(S2) 仍然是 16。但如果把 v 放在最后，
// 比如 char c, int i, double v，则总大小会变成 24。
```

### 4.3 联合体 (Unions)

- 联合体的所有成员共享同一块内存空间。
- 它的大小由其最大的成员的大小决定。
- 联合体的一个巧妙用途是，在不进行类型转换的情况下，查看一个数据类型的位级表示。例如，通过联合体我们可以直接访问一个 `float` 变量的二进制位模式，就好像它是一个 `unsigned int` 一样。

---

## 第 5 章：程序的机器级表示：高级主题与安全

本章探讨一些更高级的话题，重点是现代安全领域最核心的挑战之一：缓冲区溢出。

### 5.1 缓冲区溢出 (Buffer Overflow)

- **定义**：当程序向一个缓冲区（通常是栈上的字符数组）写入的数据超出了其边界时，就会发生缓冲区溢出。
- **栈破坏 (Stack Smashing)**：由于栈上存放着局部变量、保存的寄存器状态以及**返回地址**，缓冲区溢出可能会覆盖这些关键数据。最危险的情况是，攻击者可以精心构造输入，精确地覆盖函数的**返回地址**。
- **代码注入攻击**：
    1. 攻击者将一段恶意的机器代码（称为 *shellcode*）作为输入字符串的一部分。
    2. 通过溢出，他们用这段恶意代码的起始地址来覆盖原始的返回地址。
    3. 当函数执行 `ret` 指令时，程序不会返回到调用者，而是会跳转到攻击者注入的代码并执行它，从而获得系统的控制权。

### 5.2 对抗缓冲区溢出攻击的机制

为了应对这类攻击，现代系统采取了多种防御措施。

1. **栈随机化 (Stack Randomization)**
    - 也称为**地址空间布局随机化 (ASLR)**，程序每次运行时，栈的起始地址都是随机的。
    - 这使得攻击者难以预测他们注入的代码的准确地址，从而让攻击变得非常困难。

2. **栈金丝雀/栈保护 (Stack Canaries)**
    - 编译器在函数的栈帧中，在任何缓冲区和返回地址之间，放置一个特殊的随机值，称为 **“金丝雀” (canary)** 。
    - 在函数返回之前，程序会检查这个金丝雀的值是否被改变。如果被改变，说明发生了缓冲区溢出，程序会立即终止，而不是执行被篡改的返回地址。

3. **非可执行内存 (Non-Executable Memory)**
    - 现代处理器允许将内存区域标记为“可读”、“可写”或“可执行”。
    - 通过将栈内存区域标记为不可执行，即使攻击者成功注入了代码，CPU 也会拒绝执行该代码，从而阻止了攻击。

### 5.3 返回导向编程 (Return-Oriented Programming - ROP)

ROP 是一种更高级的攻击技术，旨在绕过“非可执行内存”的防御。

- **核心思想**：攻击者不注入新代码，而是在现有代码（如标准库 `libc`）中寻找一系列有用的、以 `ret` 指令结尾的短指令序列，这些序列被称为 **“小工具” (gadgets)** 。
- **攻击方式**：攻击者通过缓冲区溢出，用一连串精心挑选的 gadget 的地址来覆盖栈。当第一个 `ret` 指令执行时，它会跳转到第一个 gadget；当这个 gadget 执行完毕后的 `ret` 又会从栈上弹出下一个 gadget 的地址并跳转...如此往复，将这些小程序片段串联起来，执行复杂的恶意操作。

---
