## 第 3 章：程序的机器级表示 (深度解析版)

本章的目标是让你能够阅读和理解由 C 编译器生成的 x86-64 汇编代码。这不仅是理解“程序如何工作”的基础，也是进行高级性能优化和安全分析的必备技能。

### 3.1 基础：寄存器、操作数与数据移动

#### 寄存器 (Registers)

寄存器是 CPU 中最核心、速度最快的存储单元。x86-64 架构提供了 16 个 64 位的通用目的寄存器。**理解每个寄存器的惯例用途至关重要**。

- **通用寄存器与主要用途**：
    - `%rax`: **返回值**。函数执行完毕后，返回值通常存放在这里。
    - `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`: **前六个函数参数**。按照从左到右的顺序依次使用。
    - `%rsp`: **栈指针**。它始终指向运行时栈的栈顶，地址随着 `push` 和 `pop` 操作而改变。
    - `%rbp`: **基址/帧指针 (可选)**。可以用来标记当前栈帧的起点，方便访问局部变量和参数。
    - `%r10`, `%r11`: **调用者保存**的临时寄存器。
    - `%rbx`, `%r12`-%r15: **被调用者保存**的临时寄存器。

#### 操作数 (Operands)

一条汇编指令的操作数指定了要操作的数据来源和存放结果的目标。

- **立即数 (Immediate)**: 常量值，如 `$0x100`。
- **寄存器 (Register)**: 16 个通用寄存器之一，如 `%rax`。
- **内存引用 (Memory)**: 访问内存中的数据，其地址通过寻址模式计算得出。

#### 数据移动 (`mov`) 与栈操作 (`push`/`pop`)

- `movq S, D`: 这是最基本的数据移动指令，将源 `S` 的值复制到目标 `D`。
    - **核心限制**: x86-64 **不支持单条指令完成内存到内存的传送**。这是一个基础但重要的架构约束，任何内存间的数据复制都必须通过一个寄存器作为中介来完成。
- `pushq src`: 将栈指针 `%rsp` 向下（低地址）移动 8 个字节，然后将 `src` 的值写入新的栈顶地址。
- `popq dst`: 从当前栈顶地址读取值到 `dst`，然后将栈指针 `%rsp` 向上（高地址）移动 8 个字节。

### 3.2 核心：地址计算与 `leaq`

#### 寻址模式 (Addressing Modes)

掌握寻址模式是阅读汇编代码的关键。x86-64 最通用的寻址模式是 $D(R_b, R_i, S)$，它涵盖了所有其他简单形式。

- **计算公式**: 地址 = $D + Reg[R_b] + Reg[R_i] \cdot S$
- `D`: 常量位移
- `R_b`: 基址寄存器
- `R_i`: 变址寄存器
- `S`: 比例因子 (只能是 1, 2, 4, 8)

例如，`8(%rbp)` 是 $8 + Reg[\%rbp]$，而 `(%rax)` 是 $Reg[\%rax]$。

#### `leaq` 指令的威力

`leaq src, dst` (Load Effective Address) 是 x86-64 中最巧妙的指令之一。

- **核心功能**: 它计算出 `src` 操作数所代表的**地址**，并将这个地址值本身存入 `dst` 寄存器。它**从不访问内存**。
- **双重用途**:
    1. **计算地址**: 用于获取指针，如 `leaq 8(%rbp), %rax` 就是将 `%rbp+8` 这个地址加载到 `%rax`。
    2. **高效算术**: 编译器常用它来执行简单的算术运算。例如，`leaq (%rdi, %rdi, 4), %rax` 可以用一条指令计算 `x + 4*x`，即 `5*x` (假设 `x` 在 `%rdi` 中)。

### 3.3 控制流：条件码与跳转

#### 条件码 (Condition Codes)

CPU 内部有四个极其重要的单个 bit 的条件码寄存器，它们是实现所有条件分支的基础。

- `ZF` (零标志): 当运算结果为 0 时设置。
- `SF` (符号标志): 当运算结果为负数时设置。
- `CF` (进位标志): 用于无符号运算，当最高位产生进位时设置。
- `OF` (溢出标志): 用于有符号运算，当发生正或负溢出时设置。

#### 设置与读取条件码

- `cmpq b, a` 和 `testq b, a` 是专门用来设置条件码的指令，它们不修改任何其他寄存器。`cmp` 基于减法 `a-b` 设置，`test` 基于位与 `a&b` 设置。`testq %rax, %rax` 是检查 `%rax` 是否为 0 的常用方法。
- `setX dst` 和 `jX target` 指令根据条件码的状态来行动。`setX` 指令将一个字节设置为 0 或 1，而 `jX` 指令决定是否跳转。所有 C 语言的 `if`、`while`、`for` 最终都由这些指令实现。

#### `switch` 语句和跳转表

对于密集的 `switch` 语句，编译器会生成一个**跳转表 (Jump Table)**。这是一个数组，存储了每个 `case` 代码块的地址。程序通过一次数组查找和一次**间接跳转** (`jmp *target`) 直接到达目标代码，这比一长串 `if-else` 判断高效得多。

### 3.4 过程调用：栈帧与寄存器惯例

#### 栈帧 (Stack Frame)

每次函数调用，都会在栈上为其分配一个区域，称为**栈帧**。这个栈帧包含了函数执行所需的所有局部状态：传递给该函数的参数、返回地址、保存的寄存器值以及局部变量。

#### 寄存器使用惯例

这是 x86-64 过程调用中最核心的约定，它确保了函数调用不会意外地破坏调用者的状态。

- **参数传递**: 前六个整型/指针参数通过 `%rdi, %rsi, %rdx, %rcx, %r8, %r9` 传递。
- **调用者保存 (Caller-Saved)**: 包括**所有参数寄存器**以及 `%rax`, `%r10`, `%r11`。**规则**: 当函数 P 调用函数 Q 时，P 必须假定 Q 会修改这些寄存器。如果 P 在调用 Q 之后还需要用到这些寄存器的值，P **必须在调用前**将它们保存到自己的栈帧中。
- **被调用者保存 (Callee-Saved)**: 包括 `%rbx, %rbp, %r12-%15`。**规则**: 函数 Q **必须保证**在它返回时，这些寄存器的值与它被调用时完全相同。如果 Q 需要使用这些寄存器，它**必须在开头**将它们的原始值压栈保存，并在返回前恢复它们。

理解这个惯例是调试涉及函数调用的汇编代码的关键。

#### 递归 (Recursion)

递归函数的实现与普通函数调用并无二致。每一次递归调用都会创建一个全新的、独立的栈帧。因此，不同调用层次之间的局部变量和状态互不干扰，使得递归能够正确工作。

---
