# ICS

## 第 2 章：信息的表示和处理

本章重点介绍计算机如何使用二进制位来表示数字（包括整数和浮点数），以及如何对这些表示进行算术和逻辑运算。理解这部分内容对于编写正确、高效且可移植的代码至关重要。

### 2.1 信息的二进制表示

计算机中的所有数据最终都以二进制位（bit）的形式存储。为了方便读写，我们通常使用**十六进制（Hexadecimal）** 作为二进制的简写形式。

- **字节（Byte）**：是计算机中最小的可寻址内存单位，由 8 个位组成。
- **数据类型的大小**：在 C 语言中，不同的数据类型在不同位数的机器上可能占用不同大小的字节。例如，`long` 类型在 32 位系统上通常是 4 字节，而在 64 位系统上是 8 字节。

### 2.2 位运算与移位运算

C 语言提供了强大的位运算符，可以直接对整数的位模式进行操作。

- **位逻辑运算**：
    - `&` (按位与): `0101 & 0110` -> `0100`
    - `|` (按位或): `0101 | 0110` -> `0111`
    - `^` (按位异或): `0101 ^ 0110` -> `0011`
    - `~` (按位取反): `~0101` -> `1010`
- **逻辑运算 vs. 位运算**：注意区分逻辑运算符 `&&`、`||`、`!` 和位运算符 `&`、`|`、`~`。逻辑运算符将任何非零值视为 `true`，只返回 `0` 或 `1`，并且具有“短路”特性，是一个常见的编程陷阱。
- **移位运算**：
    - `<<` (左移)：向左移动位，右边补 0。`x << k` 等效于 `x * 2^k`。
    - `>>` (右移)：向右移动位。分为两种：
        - **逻辑右移**：左边补 0。用于无符号数。
        - **算术右移**：左边补最高有效位（符号位）。用于有符号数。

### 2.3 整数的表示

整数分为**无符号（Unsigned）** 和**有符号（Signed）** 两种类型。

- **无符号整数**：所有位都用来表示数值的大小。一个 $w$ 位的无符号数可以表示的范围是 $0$ 到 $2^w - 1$。
- **有符号整数**：最常用的是**补码（Two's Complement）** 表示法。
    - **最高有效位 (MSB)** 是**符号位**，0 代表非负数，1 代表负数。
    - 一个 $w$ 位的补码数可以表示的范围是 $-2^{w-1}$ 到 $2^{w-1} - 1$，这是一个不对称的范围。
    - 正数的补码就是其本身。负数的补码可以通过将其对应的正数按位取反再加 1 得到。例如，对于一个 8 位整数，-1 的补码是 `~1 + 1` -> `11111110 + 1` -> `11111111`。

#### C 语言中的整数转换与陷阱

在 C 语言中，当有符号数和无符号数混合运算时，有符号数会**隐式地转换为无符号数**，这常常导致违反直觉的结果。

```c
// C 语言中的转换陷阱
// 表达式 -1 < 0U 的结果是什么？
// 结果是 false。因为 -1 (有符号) 被转换为了一个非常大的无符号数 (UMax)，
// 所以表达式变为 UMax < 0，结果为假。

int x = -1;
unsigned int y = 0;

if (x < y) {
    printf("-1 < 0U is TRUE\n"); // 这行不会被执行
} else {
    printf("-1 < 0U is FALSE\n"); // 这行会被执行
}
```

### 2.4 整数的扩展与截断

- **扩展（Converting to a Larger Data Type）**：
    - **零扩展**：对于无符号数，在高位添加 0。
    - **符号扩展**：对于有符号数，在高位添加符号位的副本。
- **截断（Converting to a Smaller Data Type）**：
    - 直接丢弃高位比特。
    - 对于无符号数，效果等同于模 $2^k$（k 是目标类型的位数）。
    - 对于有符号数，结果可能会改变符号。

### 2.5 整数运算

- **加法**：
    - 无符号加法和补码加法的位级表示是完全相同的。
    - **无符号加法溢出**：当结果超出了表示范围时发生，相当于结果对 $2^w$ 取模。
    - **补码加法溢出**：当两个正数相加得到负数，或两个负数相加得到正数时发生。
- **乘法**：
    - 计算机执行的乘法运算会截断结果，只保留低 $w$ 位。
    - 对于无符号乘法，这相当于计算 `(x * y) mod 2^w`。
    - 对于补码乘法，位级行为与无符号乘法一致。
- **乘以/除以 2 的幂**：
    - 可以通过移位运算高效实现。左移 $k$ 位等效于乘以 $2^k$。
    - 右移 $k$ 位等效于除以 $2^k$。对于负数的除法，需要进行**偏置 (biasing)** 来保证向零舍入的正确性。

### 2.6 浮点数表示 (IEEE 754)

为了表示小数，计算机系统采用 **IEEE 754** 浮点标准。一个浮点数被编码为：$V = (-1)^s \times M \times 2^E$。

- **符号 (s)**：1 位，决定数的正负。
- **阶码 (E)**：由 `exp` 字段编码，是一个有符号整数。
- **尾数 (M)**：由 `frac` 字段编码，是一个二进制小数。

根据 `exp` 和 `frac` 的值，浮点数分为三种类型：

1. **规格化的 (Normalized)**
    - 条件：`exp` 既不全为 0，也不全为 1。
    - 阶码：$E = exp - Bias$，其中 $Bias = 2^{k-1} - 1$（k 是 exp 的位数）。
    - 尾数：$M = 1 + frac$。有一个隐含的、值为 1 的前导位。这是最常见的情况。

2. **非规格化的 (Denormalized)**
    - 条件：`exp` 全为 0。
    - 用于表示非常接近 0 的数和 0 本身。
    - 阶码：$E = 1 - Bias$。
    - 尾数：$M = frac$。没有隐含的前导 1。

3. **特殊值 (Special)**
    - 条件：`exp` 全为 1。
    - 如果 `frac` 全为 0，表示**无穷大 (infinity)**，正负取决于符号位 s。
    - 如果 `frac` 不为 0，表示 **“不是一个数” (NaN, Not-a-Number)** 。

### 2.7 浮点数舍入与运算

由于表示是有限的，浮点运算的结果通常需要舍入。

- **舍入模式**：IEEE 754 定义了四种舍入模式，默认是**向偶数舍入 (Round-to-even)**。这种模式在统计上偏差最小。
- **浮点运算**：基本思想是先计算出精确值，然后根据舍入模式调整到最接近的可表示值。
- **运算性质**：浮点加法不满足结合律，因为舍入会引入误差。`(3.14 + 1e20) - 1e20` 的结果是 `0.0`，而 `3.14 + (1e20 - 1e20)` 的结果是 `3.14`。

---
