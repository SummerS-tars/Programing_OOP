# ICS

## 第 3 章：程序的机器级表示

本章我们将学习 x86-64 架构下的汇编语言，它是 C 语言和处理器硬件之间的桥梁。我们将探索数据的表示和移动、算术运算、控制流（如循环和分支）以及过程（函数）调用在机器层面是如何实现的。

### 3.1 基础知识与数据格式

- **ISA (指令集架构)**：定义了处理器状态、指令格式以及每条指令对状态的影响，是软件和硬件之间的契约。我们主要关注 x86-64 架构。
- **C 到汇编**：我们可以使用 `gcc -Og -S a.c` 命令来让编译器将 C 语言代码编译成汇编代码 `a.s` 文件，从而观察程序的机器级表示。
- **数据格式**：x86-64 指令的后缀通常表示操作数的大小。例如 `movb` (字节, 1 byte), `movw` (字, 2 bytes), `movl` (双字, 4 bytes), `movq` (四字, 8 bytes)。

### 3.2 访问信息

- **寄存器 (Registers)**：x86-64 CPU 包含 16 个 64 位的通用目的寄存器，用于存储整数和指针。
    - `%rax`: 通常用作返回值。
    - `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`: 用于传递前六个函数参数。
    - `%rsp`: 栈指针，指向栈顶。
    - 其他寄存器如 `%rbx`, `%rbp`, `%r10` - `%r15` 也有专门的用途。

- **操作数类型 (Operand Types)**：指令的操作数可以是三种类型：
    - **立即数 (Immediate)**：常量值，在汇编中以 `$` 开头，如 `$577`。
    - **寄存器 (Register)**：16 个通用寄存器之一，如 `%rax`。
    - **内存引用 (Memory)**：根据计算出的地址访问内存中的数据。

- **`mov` 指令**：是最基本的数据传送指令，用于在寄存器和内存之间移动数据。格式为 `movq source, destination`。
    - **重要限制**：`mov` 指令不能实现一次性的**内存到内存**的复制。需要两条指令来完成：先从内存加载到寄存器，再从寄存器存储到另一内存地址。

- **寻址模式 (Addressing Modes)**：x86-64 支持多种复杂的寻址模式，最常用的是 `D(Rb, Ri, S)` 形式。
    - 它表示的地址为：`Mem[Reg[Rb] + S * Reg[Ri] + D]`。
    - `D`: 常量位移 (Displacement)。
    - `Rb`: 基址寄存器 (Base)。
    - `Ri`: 变址寄存器 (Index)。
    - `S`: 比例因子 (Scale)，值必须是 1, 2, 4, 或 8。

### 3.3 算术与逻辑操作

- **`leaq` 指令 (Load Effective Address)**：这是一个非常重要的指令，它的功能是**计算地址**并将其存入目标寄存器，但**不访问内存**。它常被编译器用来高效地执行简单的算术运算。
    - 例如，`leaq (%rdi, %rsi, 4), %rax` 可以将 `rdi + rsi * 4` 的值存入 `%rax`，实现了两次乘法和一次加法的功能。

- **算术与逻辑指令**：包括加 (`addq`)、减 (`subq`)、与 (`andq`)、或 (`orq`)、异或 (`xorq`) 等。这些指令通常有两个操作数，格式为 `op source, destination`，其效果是 `destination = destination op source`。

### 3.4 控制 (Control Flow)

- **条件码 (Condition Codes)**：CPU 维护一组单个 bit 的条件码寄存器，用于描述最近一次算术或逻辑运算的结果的属性。
    - `CF`: 进位标志，用于无符号数溢出。
    - `ZF`: 零标志，当结果为 0 时设置。
    - `SF`: 符号标志，当结果为负时设置。
    - `OF`: 溢出标志，用于有符号数溢出。

- **`cmp` 和 `test` 指令**：这两条指令只设置条件码，不改变其他寄存器的值。
    - `cmpq src2, src1`：基于 `src1 - src2` 的结果设置条件码。
    - `testq src2, src1`：基于 `src1 & src2` 的结果设置条件码。

- **跳转指令 (Jump Instructions)**：根据条件码的状态来改变程序的执行流。
    - `jmp`：无条件跳转。
    - `je` (jump when equal), `jg` (jump when greater), `jl` (jump when less) 等：条件跳转。

- **循环的实现**：C 语言中的 `for`, `while`, `do-while` 循环都可以被翻译成使用条件测试和跳转指令实现的汇编代码。

- **Switch 语句的实现**：对于多分支的 `switch` 语句，编译器会使用一种高效的实现方式，称为**跳转表 (Jump Table)**。跳转表是一个数组，存储了每个 case 对应的代码块的地址。执行 `switch` 时，程序通过索引跳转表直接跳转到目标代码，避免了冗长的 `if-else-if` 链。

### 3.5 过程 (Procedures)

过程（即函数）是软件中一种重要的抽象。

- **运行时栈 (The Stack)**：x86-64 使用栈来支持函数调用。栈向低地址方向增长，`%rsp` 寄存器始终指向栈顶元素。
    - `pushq src`：将 `%rsp` 减 8，然后将 `src` 的值存入新的栈顶地址。
    - `popq dest`：从栈顶读取值到 `dest`，然后将 `%rsp` 加 8。

- **调用与返回**：
    - `call label`：将返回地址（`call` 指令之后的那条指令的地址）压入栈中，然后跳转到 `label` 处。
    - `ret`：从栈中弹出返回地址，并跳转到该地址。

- **栈帧 (Stack Frame)**：每个函数在调用时都会在栈上分配一个独立的区域，称为栈帧，用于存储返回信息、局部变量和参数。

- **参数传递**：x86-64 约定，前 6 个整数或指针类型的参数通过寄存器传递，顺序为 `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`。超过 6 个的参数则通过栈来传递。

- **寄存器使用惯例**：为了防止函数调用时相互覆盖对方的数据，x86-64 建立了一套寄存器使用惯例。
    - **调用者保存 (Caller-Saved)**：寄存器 `%rax` 以及用于传递参数的 `%rdi` - `%r9`, `%r10`, `%r11` 属于调用者保存寄存器。当函数 P 调用函数 Q 时，P 必须自己负责保存这些寄存器的值，因为 Q 可以随意修改它们。
    - **被调用者保存 (Callee-Saved)**：寄存器 `%rbx`, `%rbp`, `%r12` - `%r15` 属于被调用者保存寄存器。Q 必须在返回前将这些寄存器的值恢复到调用前的状态。

- **递归 (Recursion)**：由于每个函数调用都有自己的私有栈帧，递归的实现方式与普通函数调用并无二致，遵循同样的栈纪律和寄存器保存惯例。

---
