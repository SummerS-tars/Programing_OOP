## 第 2 章：信息的表示和处理 (进阶版 v2.0)

本章的核心是理解计算机如何用二进制位来表示数字（包括整数和浮点数），以及如何对这些表示进行运算。这是后续所有章节的基础。

### 2.1 信息的二进制表示与字节序

计算机中所有的数据都由比特（bits）构成，通常每 8 个比特组成一个**字节 (Byte)**。对于跨越多个字节的数据类型（如 `int`, `double`），其在内存中的字节排列顺序是一个关键概念，这被称为**字节序 (Byte Ordering)**。

- **小端法 (Little-Endian)**：数据的**最低有效字节 (Least Significant Byte, LSB)** 存放在**最低**的内存地址处。**x86-64 架构使用小端法**。
- **大端法 (Big-Endian)**：数据的**最高有效字节 (Most Significant Byte, MSB)** 存放在**最低**的内存地址处。常用于网络传输协议（即网络字节序）。

> 理解字节序对于网络编程和跨平台数据文件分析至关重要。

### 2.2 位运算与移位运算

C 语言提供了一套强大的位运算符，用于直接操作数据的位模式。

- **位逻辑运算**：包括按位与 `&`、按位或 `|`、按位异或 `^` 和按位取反 `~`。这些运算常用于掩码操作，以隔离、设置或清除特定的位。
- **移位运算**：
    - **左移 `<<`**：`x << k` 将 `x` 左移 k 位，右侧补 0。
    - **右移 `>>`**：分为两种类型：
        - **逻辑右移**：在左侧补 0。用于**无符号数**。
        - **算术右移**：在左侧补**符号位**的副本。用于**有符号数**。

> **注意**：逻辑运算符 `&&` 和 `||` 存在“短路求值”特性，而位运算符 `&` 和 `|` 则没有。混用这两者是 C 语言中一个常见的编程错误。

### 2.3 整数表示

- **无符号整数 (Unsigned)**：直接使用二进制表示法，其值为 $B2U(X) = \sum_{i=0}^{w-1} x_i \cdot 2^i$。
- **有符号整数 (Signed)**：现代计算机普遍采用**补码 (Two's Complement)** 表示法。
    - **优点**：补码使得计算机可以用同样的加法器硬件来处理有符号数和无符号数的加法，极大地简化了 CPU 设计。
    - **表示**：其值为 $B2T(X) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$。最高位是**符号位**。
    - **不对称范围**：一个 w 位的有符号数范围为 $[-2^{w-1}, 2^{w-1}-1]$。最小负数 `TMin` 没有与之对应的正数。因此 `abs(TMin)` 的结果仍为 `TMin`，这是一个潜在的 bug 源头。
    - **类型转换**：在 C 语言中，当有符号数和无符号数混合运算时，**有符号数会隐式转换为无符号数**。这会导致一些违反直觉的比较结果，例如 `-1 > 0U` 的结果为真。

### 2.4 整数的扩展与截断

- **扩展 (Promotion)**：从一个较小的数据类型转换为较大的数据类型时，无符号数进行**零扩展**（高位补 0），有符号数进行**符号扩展**（高位补充符号位）。
- **截断 (Truncation)**：从一个较大的数据类型转换为较小的数据类型时，直接丢弃高位比特。

### 2.5 整数运算与溢出

- **无符号溢出**：当结果超出无符号数的表示范围时，会发生**回环 (wrap-around)**，其行为是明确定义的，相当于对 $2^w$ 取模。
- **有符号溢出**：当结果超出了有符号数的表示范围时发生（如两个正数相加得到负数）。在 C 语言标准中，有符号溢出是**未定义行为 (undefined behavior)**，程序员不应依赖其任何特定行为。

### 2.6 浮点数表示 (IEEE 754)

浮点数采用 $V = (-1)^s \times M \times 2^E$ 的形式来表示小数。一个浮点数的位表示分为三个字段：

- 1 位的**符号字段 `s`**。
- k 位的**阶码字段 `exp`**。
- n 位的**小数字段 `frac`**。

根据 `exp` 的值，编码被分为三种情况：

1. **规格化的 (Normalized)**
    - **条件**：`exp` 的位模式既不全为 0，也不全为 1。
    - **阶码**：$E = exp - Bias$。其中 $Bias = 2^{k-1} - 1$ 是一个偏置值。
    - **尾数**：$M = 1 + frac$。`frac` 是二进制小数点右边的部分，小数点左边的 1 是**隐含的**，不占用位。这是表示浮点数的最常见情况。

2. **非规格化的 (Denormalized)**
    - **条件**：`exp` 的位模式全为 0。
    - **目的**：用于表示非常接近 0 的数，以及 0 本身。
    - **阶码**：$E = 1 - Bias$ (注意不是 `-Bias`)。
    - **尾数**：$M = frac$。此时，尾数没有隐含的 1。

3. **特殊值 (Special)**
    - **条件**：`exp` 的位模式全为 1。
    - 当 `frac` 全为 0 时，表示**无穷大 (infinity)**。
    - 当 `frac` 不为 0 时，表示 **“不是一个数” (NaN, Not-a-Number)**，用于表示如 $\sqrt{-1}$ 或 $\infty - \infty$ 这样的无效运算结果。

### 2.7 浮点数舍入与运算

- **舍入 (Rounding)**：由于表示精度有限，浮点运算的结果几乎总是被舍入的。IEEE 754 定义了四种舍入模式，系统的默认模式是**向偶数舍入 (Round-to-even)**。
    - **规则**：将数字向上或向下舍入，使得结果的最低有效数字是偶数。例如，将以下数字舍入到最近的整数：
        - `1.4` $\rightarrow$ `1`
        - `1.6` $\rightarrow$ `2`
        - `1.5` $\rightarrow$ `2` (2 是偶数)
        - `2.5` $\rightarrow$ `2` (2 是偶数)
    - **优点**：在统计上是无偏的，避免了在大量计算中系统性地向上或向下舍入造成的累积误差。

- **浮点运算**：
    - **步骤**：先计算出理想的精确结果，然后将其舍入到目标浮点格式所能表示的最接近的值。
    - **代数性质**：由于舍入的存在，浮点运算不满足常规的代数定律。例如，加法和乘法**不满足结合律**。`(a+b)+c` 不一定等于 `a+(b+c)`。这对编译器优化和要求高精度的科学计算带来了挑战。

---
